import assert from "node:assert/strict";
import { readFileSync } from "node:fs";
import { resolve } from "node:path";
import test from "node:test";

const src = readFileSync(resolve(process.cwd(), "monitor.mjs"), "utf8");

test("monitor-monitor status reports in-progress run instead of never", () => {
  assert.match(src, /function formatDurationMs\(ms\)/);
  assert.match(src, /function buildMonitorMonitorStatusText\(\s*reason = "heartbeat",\s*currentSdk = getCurrentMonitorSdk\(\),/);
  assert.match(src, /- Current SDK: \$\{currentSdk\}/);
  assert.match(src, /const lastAttemptTrigger =/);
  assert.match(src, /const lastAttempted =/);
  assert.match(src, /const lastSkipReason = String\(monitorMonitor\.lastSkipReason \|\| ""\)\.trim\(\)/);
  assert.match(src, /const lastSkipped =/);
  assert.match(src, /const supervisorLastStarted =/);
  assert.match(src, /const supervisorRestartWindowMin = Math\.max\(/);
  assert.match(src, /const supervisorRestartCountWindow = Math\.max\(/);
  assert.match(src, /const supervisorRestartsUntilWarn = Math\.max\(/);
  assert.match(src, /MONITOR_MONITOR_SKIP_STREAK_WARN_THRESHOLD = parseEnvInteger\(/);
  assert.match(src, /DEVMODE_MONITOR_MONITOR_SKIP_STREAK_WARN_THRESHOLD/);
  assert.match(src, /MONITOR_MONITOR_SKIP_STREAK_WARN_MIN_GAP_MS = parseEnvInteger\(/);
  assert.match(src, /DEVMODE_MONITOR_MONITOR_SKIP_STREAK_WARN_MIN_GAP_MS/);
  assert.match(src, /MONITOR_MONITOR_SUPERVISOR_RESTART_WARN_WINDOW_MS = parseEnvInteger\(/);
  assert.match(src, /DEVMODE_MONITOR_MONITOR_SUPERVISOR_RESTART_WARN_WINDOW_MS/);
  assert.match(src, /MONITOR_MONITOR_SUPERVISOR_RESTART_WARN_THRESHOLD = parseEnvInteger\(/);
  assert.match(src, /DEVMODE_MONITOR_MONITOR_SUPERVISOR_RESTART_WARN_THRESHOLD/);
  assert.match(src, /- Last attempt trigger: \$\{lastAttemptTrigger \|\| "n\/a"\} \(\$\{lastAttempted\}\)/);
  assert.match(src, /- Last skip: \$\{lastSkipReason \|\| "none"\} \(\$\{lastSkipped\}\)/);
  assert.match(src, /- Skip streak: \$\{Math\.max\(0, Number\(monitorMonitor\.skipStreak \|\| 0\)\)\}/);
  assert.match(src, /- Supervisor restarts \(window \$\{supervisorRestartWindowMin\}m\): \$\{supervisorRestartCountWindow\}/);
  assert.match(src, /- Supervisor restarts until warn: \$\{supervisorRestartsUntilWarn\}/);
  assert.match(src, /- Supervisor starts: total=\$\{Math\.max\(0, Number\(monitorMonitor\.supervisorStartCountTotal \|\| 0\)\)\}, last=\$\{supervisorLastStarted\}/);
  assert.match(src, /skip-warn>=\$\{MONITOR_MONITOR_SKIP_STREAK_WARN_THRESHOLD\}/);
  assert.match(src, /skip-warn-gap>=\$\{Math\.round\(MONITOR_MONITOR_SKIP_STREAK_WARN_MIN_GAP_MS \/ 1000\)\}s/);
  assert.match(src, /monitorMonitor\.running && Number\.isFinite\(monitorMonitor\.heartbeatAt\)/);
  assert.match(src, /in progress \(\$\{formatDurationMs\(runAgeMs\)\}\)/);
  assert.match(src, /String\(monitorMonitor\.lastOutcome \|\| ""\)\.toLowerCase\(\) === "not-started"/);
  assert.match(src, /const lastOutcome =/);
  assert.match(src, /- Last outcome: \$\{lastOutcome\}/);
});

test("monitor-monitor startup status dedup suppresses rapid duplicate startup updates", () => {
  assert.match(src, /MONITOR_MONITOR_STARTUP_CYCLE_DELAY_MS = parseEnvInteger\(/);
  assert.match(src, /DEVMODE_MONITOR_MONITOR_STARTUP_CYCLE_DELAY_MS/);
  assert.match(src, /MONITOR_MONITOR_STARTUP_STATUS_DELAY_MS = parseEnvInteger\(/);
  assert.match(src, /DEVMODE_MONITOR_MONITOR_STARTUP_STATUS_DELAY_MS/);
  assert.match(src, /MONITOR_MONITOR_STARTUP_STATUS_AFTER_CYCLE_MIN_MS = parseEnvInteger\(/);
  assert.match(src, /DEVMODE_MONITOR_MONITOR_STARTUP_STATUS_AFTER_CYCLE_MIN_MS/);
  assert.match(src, /MONITOR_MONITOR_STARTUP_JITTER_MS = parseEnvInteger\(/);
  assert.match(src, /DEVMODE_MONITOR_MONITOR_STARTUP_JITTER_MS/);
  assert.match(src, /MONITOR_MONITOR_STARTUP_STATUS_MIN_GAP_MS = parseEnvInteger\(/);
  assert.match(src, /DEVMODE_MONITOR_MONITOR_STARTUP_STATUS_MIN_GAP_MS/);
  assert.match(src, /MONITOR_MONITOR_STARTUP_STATUS_GATE_PATH = resolve\(/);
  assert.match(src, /MONITOR_MONITOR_STARTUP_STATUS_GATE_TMP_PATH/);
  assert.match(src, /MONITOR_MONITOR_STARTUP_STATUS_GATE_CORRUPT_PREFIX/);
  assert.match(src, /MONITOR_MONITOR_STARTUP_STATUS_GATE_CORRUPT_MAX_FILES = parseEnvInteger\(/);
  assert.match(src, /DEVMODE_MONITOR_MONITOR_STARTUP_STATUS_GATE_CORRUPT_MAX_FILES/);
  assert.match(src, /const monitorMonitorStartupGateWarningKeys = new Set\(\)/);
  assert.match(src, /function warnStartupStatusGateIssueOnce\(key, message\)/);
  assert.match(src, /startup gate read failed; using fallback/);
  assert.match(src, /startup gate write failed:/);
  assert.match(src, /function cleanupStartupStatusGateTempFile\(\)/);
  assert.match(src, /function cleanupStartupStatusGateCorruptFiles\(\)/);
  assert.match(src, /cleanupStartupStatusGateTempFile\(\);/);
  assert.match(src, /cleanupStartupStatusGateCorruptFiles\(\);/);
  assert.match(src, /readdirSync\(gateDir\)/);
  assert.match(src, /candidates\.slice\(MONITOR_MONITOR_STARTUP_STATUS_GATE_CORRUPT_MAX_FILES\)/);
  assert.match(src, /function readStartupStatusGateTs\(\)/);
  assert.match(src, /function writeStartupStatusGateTs\(tsMs\)/);
  assert.match(src, /const maxFutureSkewMs = Math\.max\(/);
  assert.match(src, /MONITOR_MONITOR_STARTUP_STATUS_MIN_GAP_MS/);
  assert.match(src, /startup gate timestamp is too far in future/);
  assert.match(src, /renameSync\(\s*MONITOR_MONITOR_STARTUP_STATUS_GATE_TMP_PATH,/);
  assert.match(src, /\.corrupt-\$\{Date\.now\(\)\}/);
  assert.match(src, /unlinkSync\(MONITOR_MONITOR_STARTUP_STATUS_GATE_TMP_PATH\)/);
  assert.match(src, /startupCycleTimer: null/);
  assert.match(src, /startupStatusTimer: null/);
  assert.match(src, /monitorMonitor\.startupCycleTimer = safeSetTimeout\("monitor-monitor-startup-cycle"/);
  assert.match(src, /monitorMonitor\.startupStatusTimer = safeSetTimeout\("monitor-monitor-startup-status"/);
  assert.match(src, /const startupJitterMs =/);
  assert.match(src, /const startupCycleDelayEffectiveMs = Math\.max\(/);
  assert.match(src, /const startupStatusDelayEffectiveMs = Math\.max\(/);
  assert.match(src, /let startupStatusDelayAdjustedMs = startupStatusDelayEffectiveMs/);
  assert.match(src, /startup status delay auto-adjusted to/);
  assert.match(src, /monitor-monitor startup jitter applied:/);
  assert.match(src, /monitor-monitor startup gate: status-gap=\$\{Math\.round\(MONITOR_MONITOR_STARTUP_STATUS_MIN_GAP_MS \/ 1000\)\}s jitter<=\$\{Math\.round\(MONITOR_MONITOR_STARTUP_JITTER_MS \/ 1000\)\}s corrupt-retain=\$\{MONITOR_MONITOR_STARTUP_STATUS_GATE_CORRUPT_MAX_FILES\}/);
  assert.match(src, /MONITOR_MONITOR_STARTUP_STATUS_DELAY_MS < MONITOR_MONITOR_STARTUP_CYCLE_DELAY_MS/);
  assert.match(src, /startup status delay \(\$\{Math\.round\(MONITOR_MONITOR_STARTUP_STATUS_DELAY_MS \/ 1000\)\}s\) is below startup cycle delay/);
  assert.match(src, /clearTimeout\(monitorMonitor\.startupCycleTimer\)/);
  assert.match(src, /clearTimeout\(monitorMonitor\.startupStatusTimer\)/);
  assert.match(src, /const recentStarts = Array\.isArray\(monitorMonitor\.supervisorStartTimes\)/);
  assert.match(src, /monitorMonitor\.supervisorRestartCountWindow = recentStarts\.length/);
  assert.match(src, /monitorMonitor\.supervisorStartCountTotal = Math\.max\(/);
  assert.match(src, /monitorMonitor\.supervisorLastStartedAt = now/);
  assert.match(src, /monitor-monitor supervisor restarted \$\{recentStarts\.length\} times within/);
  assert.match(src, /monitorMonitor\.lastStatusReason === "startup"/);
  assert.match(src, /const persistedStartupStatusAt =/);
  assert.match(src, /const latestStartupStatusAt = Math\.max\(/);
  assert.match(src, /const statusSdk = getCurrentMonitorSdk\(\)/);
  assert.match(src, /const text = buildMonitorMonitorStatusText\(reason, statusSdk\)/);
  assert.match(src, /monitorMonitor\.lastAttemptTrigger = trigger/);
  assert.match(src, /monitorMonitor\.lastAttemptAt = Date\.now\(\)/);
  assert.match(src, /const heartbeatAt = Number\(monitorMonitor\.heartbeatAt \|\| 0\)/);
  assert.match(src, /Number\.POSITIVE_INFINITY/);
  assert.match(src, /const runStaleThresholdMs =/);
  assert.match(src, /monitorMonitor\.timeoutMs \+ MONITOR_MONITOR_WATCHDOG_FORCE_RESET_DELAY_MS/);
  assert.match(src, /if \(runAge > runStaleThresholdMs\)/);
  assert.match(src, /function recordMonitorMonitorSkip\(reason = "unknown"\)/);
  assert.match(src, /const skipStreak = Math\.max\(/);
  assert.match(src, /monitorMonitor\.skipStreak = skipStreak/);
  assert.match(src, /if \(skipStreak < MONITOR_MONITOR_SKIP_STREAK_WARN_THRESHOLD\) return;/);
  assert.match(src, /const now = Date\.now\(\)/);
  assert.match(src, /const lastWarnAt = Math\.max\(/);
  assert.match(src, /now - lastWarnAt < MONITOR_MONITOR_SKIP_STREAK_WARN_MIN_GAP_MS/);
  assert.match(src, /monitorMonitor\.lastSkipStreakWarned = skipStreak/);
  assert.match(src, /monitorMonitor\.lastSkipStreakWarnAt = now/);
  assert.match(src, /skip streak \$\{skipStreak\} \(reason=\$\{monitorMonitor\.lastSkipReason\}\) while prior run is still active/);
  assert.match(src, /recordMonitorMonitorSkip\("running-watchdog-await"\)/);
  assert.match(src, /recordMonitorMonitorSkip\("running-active"\)/);
  assert.match(src, /"running-no-abort-controller"/);
  assert.match(src, /force-resetting stale run without abort controller after/);
  assert.match(src, /force-reset \(no-abort-controller\)/);
  assert.match(src, /stale running=true without abort controller after/);
  assert.match(src, /monitorMonitor\.lastSkipReason = ""/);
  assert.match(src, /monitorMonitor\.lastSkipAt = 0/);
  assert.match(src, /monitorMonitor\.skipStreak = 0/);
  assert.match(src, /monitorMonitor\.lastSkipStreakWarned = 0/);
  assert.match(src, /monitorMonitor\.lastSkipStreakWarnAt = 0/);
  assert.match(src, /lastAttemptAt: monitorMonitor\.lastAttemptAt \|\| 0/);
  assert.match(src, /lastAttemptTrigger: monitorMonitor\.lastAttemptTrigger \|\| ""/);
  assert.match(src, /lastSkipAt: monitorMonitor\.lastSkipAt \|\| 0/);
  assert.match(src, /lastSkipReason: monitorMonitor\.lastSkipReason \|\| ""/);
  assert.match(src, /skipStreak: monitorMonitor\.skipStreak \|\| 0/);
  assert.match(src, /lastSkipStreakWarned: monitorMonitor\.lastSkipStreakWarned \|\| 0/);
  assert.match(src, /lastSkipStreakWarnAt: monitorMonitor\.lastSkipStreakWarnAt \|\| 0/);
  assert.match(src, /supervisorRestartCountWindow:\s*monitorMonitor\.supervisorRestartCountWindow \|\| 0/);
  assert.match(src, /supervisorRestartLastWarnAt:\s*monitorMonitor\.supervisorRestartLastWarnAt \|\| 0/);
  assert.match(src, /supervisorRestartWarnWindowMs:\s*MONITOR_MONITOR_SUPERVISOR_RESTART_WARN_WINDOW_MS/);
  assert.match(src, /supervisorRestartWarnThreshold:\s*MONITOR_MONITOR_SUPERVISOR_RESTART_WARN_THRESHOLD/);
  assert.match(src, /supervisorRestartsUntilWarn: Math\.max\(/);
  assert.match(src, /supervisorStartCountTotal: monitorMonitor\.supervisorStartCountTotal \|\| 0/);
  assert.match(src, /supervisorLastStartedAt: monitorMonitor\.supervisorLastStartedAt \|\| 0/);
  assert.match(src, /const startupStatusSeenRecently =/);
  assert.match(src, /persistedStartupStatusAt > 0/);
  assert.match(src, /Number\(monitorMonitor\.lastRunAt \|\| 0\) <= latestStartupStatusAt/);
  assert.match(src, /const prevStatusAt = monitorMonitor\.lastStatusAt/);
  assert.match(src, /const prevStatusReason = monitorMonitor\.lastStatusReason/);
  assert.match(src, /const prevStatusText = monitorMonitor\.lastStatusText/);
  assert.match(src, /try \{/);
  assert.match(src, /monitorMonitor\.lastStatusAt = prevStatusAt/);
  assert.match(src, /monitorMonitor\.lastStatusReason = prevStatusReason/);
  assert.match(src, /monitorMonitor\.lastStatusText = prevStatusText/);
  assert.match(src, /status \(\$\{reason\}\) publish failed:/);
  assert.match(src, /dedupKey: `monitor-monitor-status-\$\{reason\}-\$\{statusSdk\}`/);
  assert.match(src, /status \(\$\{reason\}\) sdk=\$\{statusSdk\} failures=/);
  assert.match(src, /writeStartupStatusGateTs\(now\)/);
  assert.doesNotMatch(src, /monitorMonitor\.lastStatusText === text/);
  assert.match(src, /status \(startup\) skipped \(duplicate within/);
});
