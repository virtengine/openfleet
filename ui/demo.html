<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:; img-src * data: blob:; connect-src *;" />
  <title>Bosun MiniApp — Demo Mode</title>

  <!-- Telegram WebApp SDK is fully mocked below — no real SDK needed -->

  <!-- es-module-shims: load from bundled vendor first, CDN as fallback -->
  <script>
    (function() {
      var shim = document.createElement("script");
      shim.async = true;
      shim.src = "./vendor/es-module-shims.js";
      shim.onerror = function() {
        var fb = document.createElement("script");
        fb.async = true;
        fb.src = "https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.min.js";
        fb.onerror = function() {
          var fb2 = document.createElement("script");
          fb2.async = true;
          fb2.src = "https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.min.js";
          document.head.appendChild(fb2);
        };
        document.head.appendChild(fb);
      };
      document.head.appendChild(shim);
    })();
  </script>

  <!-- Import map — primary: bundled vendor files (committed to git, served from
       GitHub Pages at ./vendor/ and from bosun server at /vendor/).
       The importmap-fallback JSON block below is used by the CDN fallback script
       if vendor files fail to load. -->
  <script type="importmap">
  {
    "imports": {
      "preact":                  "./vendor/preact.js",
      "preact/hooks":            "./vendor/preact-hooks.js",
      "preact/compat":           "./vendor/preact-compat.js",
      "htm":                     "./vendor/htm.js",
      "@preact/signals-core":    "./vendor/preact-signals-core.js",
      "@preact/signals":         "./vendor/preact-signals.js"
    }
  }
  </script>
  <script type="importmap-shim">
  {
    "imports": {
      "preact":                  "./vendor/preact.js",
      "preact/hooks":            "./vendor/preact-hooks.js",
      "preact/compat":           "./vendor/preact-compat.js",
      "htm":                     "./vendor/htm.js",
      "@preact/signals-core":    "./vendor/preact-signals-core.js",
      "@preact/signals":         "./vendor/preact-signals.js"
    }
  }
  </script>
  <!-- CDN fallback — used if the bundled vendor files are unavailable -->
  <script type="application/json" id="importmap-fallback">
  {
    "imports": {
      "preact":                  "https://esm.sh/preact@10.25.4",
      "preact/hooks":            "https://esm.sh/preact@10.25.4/hooks",
      "preact/compat":           "https://esm.sh/preact@10.25.4/compat",
      "htm":                     "https://esm.sh/htm@3.1.1",
      "@preact/signals-core":    "https://cdn.jsdelivr.net/npm/@preact/signals-core@1.8.0/+esm",
      "@preact/signals":         "https://esm.sh/@preact/signals@1.3.1?deps=preact@10.25.4"
    }
  }
  </script>

  <!-- Load the real MiniApp styles -->
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="styles/kanban.css" />
  <link rel="stylesheet" href="styles/sessions.css" />

  <!-- Fonts (match site) -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Instrument+Sans:wght@400;500;600;700&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet" />

  <style>
    /* ═══ DEMO LAYOUT — Telegram MiniApp (single view) ═══════════════ */
    *, *::before, *::after { box-sizing: border-box; }
    html { height: 100%; margin: 0; }
    body { height: 100%; margin: 0; font-family: "Instrument Sans", -apple-system, "SF Pro Text", "Helvetica Neue", sans-serif; background: #0b0f14; color: #e8edf2; overflow: hidden; }

    /* ── MAIN CONTAINER ── */
    .demo-container { position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column; background: #0b0f14; }

    /* MiniApp header (Telegram-style) */
    .miniapp-header { display: flex; align-items: center; gap: 8px; padding: 8px 14px; background: #17212b; border-bottom: 1px solid #1b2838; flex-shrink: 0; z-index: 10; }
    .miniapp-header-icon { width: 28px; height: 28px; border-radius: 50%; background: linear-gradient(135deg, #4cc9f0, #60cc5d); display: flex; align-items: center; justify-content: center; font-size: 14px; flex-shrink: 0; }
    .miniapp-header-title { flex: 1; font-size: 15px; font-weight: 600; color: #fff; }
    .miniapp-header-badge { font-size: 10px; color: #64748b; background: #1e293b; padding: 2px 7px; border-radius: 10px; }

    /* MiniApp content — wraps #app, MUST allow scrolling.
       overflow:clip clips border-radius visually without creating a BFC scroll
       container that would silently eat mouse-wheel events.
       #app is a normal flex child (not absolute) so the full flex chain flows
       correctly all the way down to .main-content (the real scroll container). */
    .miniapp-content { flex: 1; min-height: 0; overflow: clip; position: relative; display: flex; flex-direction: column; }
    .miniapp-content #app { flex: 1; min-height: 0; height: auto; }

    /* ── BOT MENU PANEL (slide-up, multi-layer) ── */
    .bot-panel { position: fixed; bottom: 0; left: 0; right: 0; z-index: 8999; background: #0e1621; border-top: 1px solid #1b2838; border-radius: 16px 16px 0 0; box-shadow: 0 -8px 32px rgba(0,0,0,0.5); max-height: 65vh; display: flex; flex-direction: column; transform: translateY(100%); opacity: 0; pointer-events: none; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.25s; }
    .bot-panel.open { transform: translateY(0); opacity: 1; pointer-events: auto; }

    /* Panel header */
    .bot-panel-header { display: flex; align-items: center; gap: 8px; padding: 10px 14px 6px; flex-shrink: 0; }
    .bot-panel-back { background: none; border: none; color: #4cc9f0; font-size: 18px; cursor: pointer; padding: 4px 6px; border-radius: 6px; transition: background 0.15s; display: none; }
    .bot-panel-back:hover { background: rgba(76, 201, 240, 0.1); }
    .bot-panel-back.visible { display: block; }
    .bot-panel-title { flex: 1; font-size: 14px; font-weight: 600; color: #fff; }
    .bot-panel-home { background: none; border: none; color: #5b7083; font-size: 16px; cursor: pointer; padding: 4px 6px; border-radius: 6px; transition: color 0.15s; display: none; }
    .bot-panel-home:hover { color: #4cc9f0; }
    .bot-panel-home.visible { display: block; }
    .bot-panel-close { background: none; border: none; color: #5b7083; font-size: 16px; cursor: pointer; padding: 4px 6px; border-radius: 6px; transition: color 0.15s; }
    .bot-panel-close:hover { color: #ef5350; }

    /* Panel body (scrollable text output) */
    .bot-panel-body { padding: 4px 14px 8px; font-size: 13px; line-height: 1.5; color: #94a3b8; overflow-y: auto; flex-shrink: 1; min-height: 0; }
    .bot-panel-body strong { color: #e8edf2; }
    .bot-panel-body code { background: #182533; padding: 1px 4px; border-radius: 3px; font-size: 11.5px; font-family: 'JetBrains Mono', monospace; color: #4cc9f0; }
    .bot-panel-body pre { background: #182533; padding: 8px; border-radius: 6px; font-size: 11px; margin: 6px 0; font-family: 'JetBrains Mono', monospace; overflow-x: auto; white-space: pre-wrap; color: #e8edf2; }

    /* Panel keyboard (inline buttons) */
    .bot-panel-keyboard { padding: 4px 8px 10px; flex-shrink: 0; }
    .bot-kb-row { display: flex; gap: 2px; margin-bottom: 2px; }
    .bot-kb-btn { flex: 1; background: #2b5278; border: none; border-radius: 5px; color: #fff; font-size: 12px; font-weight: 500; padding: 8px 3px; cursor: pointer; transition: background 0.12s, transform 0.1s; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .bot-kb-btn:hover { background: #3a6da0; }
    .bot-kb-btn:active { background: #1d3f5e; transform: scale(0.97); }
    .bot-kb-btn.nav-btn { background: #1e293b; color: #94a3b8; font-size: 11px; }
    .bot-kb-btn.nav-btn:hover { background: #2d3a4d; color: #e8edf2; }
    .bot-kb-btn.close-btn { background: transparent; color: #5b7083; font-size: 11px; }
    .bot-kb-btn.close-btn:hover { color: #ef5350; background: rgba(239, 83, 80, 0.08); }
    .bot-kb-btn.action-btn { background: #4cc9f0; color: #000; font-weight: 600; }
    .bot-kb-btn.action-btn:hover { background: #5dd8ff; }
    .bot-kb-btn.cmd-flash { background: #4cc9f0 !important; color: #000 !important; transition: none; }

    /* Panel result area (shows command output) */
    .bot-panel-result { display: none; padding: 4px 14px 8px; font-size: 13px; line-height: 1.5; color: #e8edf2; overflow-y: auto; max-height: 200px; border-top: 1px solid #1b2838; animation: resultIn 0.2s ease-out; }
    .bot-panel-result.visible { display: block; }
    .bot-panel-result strong { color: #fff; }
    .bot-panel-result code { background: #182533; padding: 1px 4px; border-radius: 3px; font-size: 11.5px; font-family: 'JetBrains Mono', monospace; color: #4cc9f0; }
    .bot-panel-result pre { background: #182533; padding: 8px; border-radius: 6px; font-size: 11px; margin: 6px 0; font-family: 'JetBrains Mono', monospace; overflow-x: auto; white-space: pre-wrap; }
    @keyframes resultIn { from { opacity: 0; } to { opacity: 1; } }

    /* Force dark theme */
    :root:not([data-theme="light"]) { color-scheme: dark; }
  </style>

  <!-- ═══ DEMO MOCK LAYER ═══════════════════════════════════════════════
       This script runs BEFORE the real app.js to mock:
       1. Telegram.WebApp — provides fake theme, user, initData
       2. fetch() — intercepts /api/* to return seed data
       3. WebSocket — provides fake WS connection for live updates
       ═══════════════════════════════════════════════════════════════════ -->
  <script>
  (function() {
    'use strict';

    /* ── Mock Telegram.WebApp ──────────────────────────────────────── */
    const mockUser = {
      id: 1337420,
      first_name: 'Demo',
      last_name: 'User',
      username: 'demo_user',
      language_code: 'en',
      is_premium: true,
    };

    const theme = {
      bg_color: '#0b0f14',
      text_color: '#f1f5f9',
      hint_color: '#64748b',
      link_color: '#4cc9f0',
      button_color: '#4cc9f0',
      button_text_color: '#000000',
      secondary_bg_color: '#131a24',
      header_bg_color: '#0b0f14',
      accent_text_color: '#4cc9f0',
      section_bg_color: '#131a24',
      section_header_text_color: '#94a3b8',
      subtitle_text_color: '#94a3b8',
      destructive_text_color: '#ef4444',
      section_separator_color: '#1e293b',
      bottom_bar_bg_color: '#0b0f14',
    };

    window.Telegram = {
      WebApp: {
        initData: 'demo_mode=true&user=' + encodeURIComponent(JSON.stringify(mockUser)),
        initDataUnsafe: { user: mockUser, auth_date: Date.now() },
        version: '8.0',
        platform: 'web',
        colorScheme: 'dark',
        themeParams: theme,
        isExpanded: true,
        viewportHeight: window.innerHeight,
        viewportStableHeight: window.innerHeight,
        headerColor: theme.header_bg_color,
        backgroundColor: theme.bg_color,
        bottomBarColor: theme.bottom_bar_bg_color,
        isClosingConfirmationEnabled: false,
        isVerticalSwipesEnabled: false,
        isFullscreen: true,
        safeAreaInset: { top: 0, bottom: 0, left: 0, right: 0 },
        contentSafeAreaInset: { top: 0, bottom: 0, left: 0, right: 0 },
        BackButton: {
          isVisible: false,
          show() { this.isVisible = true; },
          hide() { this.isVisible = false; },
          onClick(cb) { this._cb = cb; },
          offClick() { this._cb = null; },
        },
        MainButton: {
          isVisible: false,
          text: '',
          color: theme.button_color,
          textColor: theme.button_text_color,
          isProgressVisible: false,
          show() { this.isVisible = true; },
          hide() { this.isVisible = false; },
          setText(t) { this.text = t; },
          onClick(cb) { this._cb = cb; },
          offClick() { this._cb = null; },
          showProgress() { this.isProgressVisible = true; },
          hideProgress() { this.isProgressVisible = false; },
          enable() {},
          disable() {},
        },
        HapticFeedback: {
          impactOccurred() {},
          notificationOccurred() {},
          selectionChanged() {},
        },
        ready() {},
        expand() {},
        close() {},
        requestFullscreen() {},
        disableVerticalSwipes() {},
        enableClosingConfirmation() {},
        setHeaderColor(c) { this.headerColor = c; },
        setBackgroundColor(c) { this.backgroundColor = c; },
        setBottomBarColor(c) { this.bottomBarColor = c; },
        onEvent(name, cb) {},
        offEvent(name, cb) {},
        showConfirm(msg, cb) { if (cb) cb(true); },
        showAlert(msg, cb) { if (cb) cb(); },
        showPopup(params, cb) { if (cb) cb('ok'); },
        openLink(url) { window.open(url, '_blank'); },
        openTelegramLink(url) {},
      },
    };

    /* ── Seed Data ─────────────────────────────────────────────────── */
    const now = Date.now();
    const min = 60000;
    const hr = 3600000;
    const day = 24 * hr;

    /* ── Tasks: comprehensive 1-week board across TWO repos ──────── */
    const SEED_TASKS = [
      // ── virtengine/bosun — real PRs & issues ──
      { id: 'bosun-1',  repo: 'bosun', issueNumber: 1,  title: 'fix: address three implementation gaps in bosun', status: 'done', priority: 'high', assignee: 'copilot-swe', branch: 'copilot/assess-bosun-project-gaps', pr: 1, created: now - 6*day, updated: now - 6*day + 30*min, mergedAt: now - 6*day + 30*min },
      { id: 'bosun-2',  repo: 'bosun', issueNumber: 2,  title: 'fix(setup): harden wizard resume and github flow', status: 'done', priority: 'high', assignee: 'copilot-claude', branch: 'fix/setup-resume-gh', pr: 3, created: now - 6*day, updated: now - 5*day + 12*hr, mergedAt: now - 5*day + 12*hr },
      { id: 'bosun-3',  repo: 'bosun', issueNumber: 3,  title: 'feat(ui): redesign dashboard landing page', status: 'done', priority: 'high', assignee: 'copilot-claude', branch: 'feat/ui-redesign', pr: 4, created: now - 5*day, updated: now - 5*day + 5*hr, mergedAt: now - 5*day + 5*hr },
      { id: 'bosun-4',  repo: 'bosun', issueNumber: 4,  title: 'feat: enhance chat view message key generation', status: 'done', priority: 'medium', assignee: 'codex-default', branch: 'docs/bosun-improvement-plan', pr: 9, created: now - 4*day, updated: now - 4*day + 2*hr, mergedAt: now - 4*day + 2*hr },
      { id: 'bosun-5',  repo: 'bosun', issueNumber: 5,  title: 'feat(auth): GitHub App OAuth setup portal + auth state helpers', status: 'done', priority: 'critical', assignee: 'copilot-claude', branch: 'docs/bosun-improvement-plan', pr: 10, created: now - 3*day, updated: now - 3*day + 4*hr, mergedAt: now - 3*day + 4*hr },
      { id: 'bosun-6',  repo: 'bosun', issueNumber: 6,  title: 'fix(demo): restore CDN importmap in demo.html', status: 'done', priority: 'medium', assignee: 'codex-default', branch: 'docs/bosun-improvement-plan', pr: 16, created: now - 2*day, updated: now - 2*day + 1*hr, mergedAt: now - 2*day + 1*hr },
      { id: 'bosun-7',  repo: 'bosun', issueNumber: 7,  title: 'feat(site): redesign landing page — helm SVG, demo tabs', status: 'inprogress', priority: 'high', assignee: 'copilot-claude', branch: 'docs/bosun-improvement-plan', pr: 17, created: now - 1*day, updated: now - 2*hr },
      { id: 'bosun-11', repo: 'bosun', issueNumber: 11, title: '[m] agent logging: enrich session metadata from VK API when missing', status: 'todo', priority: 'medium', assignee: null, branch: null, pr: null, created: now - 8*hr, updated: now - 8*hr },
      { id: 'bosun-12', repo: 'bosun', issueNumber: 12, title: '[m] analytics: error-cluster correlation report for planning insights', status: 'todo', priority: 'medium', assignee: null, branch: null, pr: null, created: now - 8*hr, updated: now - 8*hr },
      { id: 'bosun-13', repo: 'bosun', issueNumber: 13, title: '[s] telegram: weekly agent work report command and scheduler', status: 'todo', priority: 'low', assignee: null, branch: null, pr: null, created: now - 8*hr, updated: now - 8*hr },
      { id: 'bosun-14', repo: 'bosun', issueNumber: null, title: 'fix(ui): kanban card repo badge + filter system', status: 'inprogress', priority: 'high', assignee: 'copilot-claude', branch: 'fix/kanban-repo-filters', pr: null, created: now - 4*hr, updated: now - 15*min },
      { id: 'bosun-15', repo: 'bosun', issueNumber: null, title: 'feat(kanban): task priority drag-and-drop reorder', status: 'draft', priority: 'medium', assignee: null, branch: null, pr: null, created: now - 2*hr, updated: now - 2*hr },
      { id: 'bosun-16', repo: 'bosun', issueNumber: null, title: 'test(ui-server): comprehensive API integration tests', status: 'inreview', priority: 'medium', assignee: 'codex-default', branch: 'test/api-integration', pr: 18, created: now - 1*day, updated: now - 3*hr },

      // ── virtengine/virtengine — real PRs ──
      { id: 've-739',  repo: 'virtengine', issueNumber: 739, title: 'feat(audit): immutable audit log with cross-module hooks', status: 'done', priority: 'critical', assignee: 'copilot-claude', branch: 've/820c-xl-p1-feat-audit', pr: 739, created: now - 6*day, updated: now - 6*day + 4*hr, mergedAt: now - 6*day + 4*hr },
      { id: 've-745',  repo: 'virtengine', issueNumber: 745, title: 'fix(security): harden TLS/SSL and HTTP client configurations', status: 'done', priority: 'high', assignee: 'codex-default', branch: 've/158-security-harden-tls-ssl', pr: 745, created: now - 5*day, updated: now - 5*day + 3*hr, mergedAt: now - 5*day + 3*hr },
      { id: 've-748',  repo: 'virtengine', issueNumber: 748, title: 'fix: resolve all common CI/CD failures properly', status: 'done', priority: 'high', assignee: 'copilot-claude', branch: 've/738-fix-all-common-ci-cd', pr: 748, created: now - 5*day, updated: now - 4*day + 6*hr, mergedAt: now - 4*day + 6*hr },
      { id: 've-749',  repo: 'virtengine', issueNumber: 749, title: 'fix(deps): remediate dependabot vulnerability alerts', status: 'done', priority: 'medium', assignee: 'codex-default', branch: 've/152-security-remediate-deps', pr: 749, created: now - 4*day, updated: now - 4*day + 2*hr, mergedAt: now - 4*day + 2*hr },
      { id: 've-751',  repo: 'virtengine', issueNumber: 751, title: 'Security: bulk remediation of remaining CodeQL/gosec alerts (~300)', status: 'done', priority: 'critical', assignee: 'copilot-claude', branch: 've/157-security-bulk-remediation', pr: 751, created: now - 3*day, updated: now - 3*day + 6*hr, mergedAt: now - 3*day + 6*hr },
      { id: 've-754',  repo: 'virtengine', issueNumber: 754, title: 'feat(cli): Codex-Monitor MiniApp Mission Control redesign', status: 'done', priority: 'high', assignee: 'copilot-claude', branch: 'feat/miniapp-redesign', pr: 754, created: now - 2*day, updated: now - 1*day + 12*hr, mergedAt: now - 1*day + 12*hr },
      { id: 've-760',  repo: 'virtengine', issueNumber: 760, title: 'feat(market): order expiry and auto-settlement', status: 'inprogress', priority: 'high', assignee: 'codex-default', branch: 've/760-market-order-expiry', pr: null, created: now - 18*hr, updated: now - 30*min },
      { id: 've-761',  repo: 'virtengine', issueNumber: 761, title: 'refactor(escrow): batch settlement pipeline', status: 'inprogress', priority: 'medium', assignee: 'copilot-claude', branch: 've/761-escrow-batch', pr: null, created: now - 12*hr, updated: now - 45*min },
      { id: 've-762',  repo: 'virtengine', issueNumber: 762, title: 'fix(veid): token validation edge cases', status: 'inreview', priority: 'high', assignee: 'codex-default', branch: 've/762-veid-token-fix', pr: 764, created: now - 1*day, updated: now - 4*hr },
      { id: 've-763',  repo: 'virtengine', issueNumber: 763, title: 'test(hpc): GPU resource metering unit tests', status: 'todo', priority: 'medium', assignee: null, branch: null, pr: null, created: now - 6*hr, updated: now - 6*hr },
      { id: 've-764',  repo: 'virtengine', issueNumber: null, title: 'docs: update provider deployment guide', status: 'draft', priority: 'low', assignee: null, branch: null, pr: null, created: now - 3*hr, updated: now - 3*hr },
    ];

    const SEED_STATUS = {
      status: 'running',
      uptime: '6d 14h 23m',
      executorMode: 'internal',
      board: 'github',
      maxParallel: 6,
      version: '0.32.0',
      tasks: { completed: 18, failed: 2, retried: 4, active: 4, queued: 6 },
      prs: { created: 22, merged: 18, pending: 3, ciFailures: 2 },
      counts: {
        running: 4,
        inprogress: 4,
        inreview: 2,
        review: 2,
        done: 12,
        todo: 4,
        draft: 2,
        error: 0,
      },
      backlog_remaining: 4,
      success_metrics: {
        first_shot_rate: 78,
        needed_fix: 4,
        failed: 2,
      },
    };

    const SEED_EXECUTORS = [
      { name: 'copilot-claude', sdk: 'copilot', model: 'claude-opus-4-6', weight: 50, status: 'active', load: 67, tasksCompleted: 8, avgTime: '12m', uptime: '2h 34m', session: 'sk-...7f3a' },
      { name: 'codex-default', sdk: 'codex', model: 'o4-mini', weight: 50, status: 'active', load: 42, tasksCompleted: 5, avgTime: '18m', uptime: '2h 34m', session: 'cx-...a91b' },
    ];

    const SEED_AGENTS = [
      {
        id: 'agent-001',
        name: 'copilot-claude',
        type: 'copilot',
        model: 'claude-opus-4-6',
        status: 'running',
        taskId: 'bosun-7',
        taskTitle: 'feat(site): redesign landing page',
        branch: 'docs/bosun-improvement-plan',
        sessionId: 'ses-001',
        index: 0,
        startedAt: now - 2 * hr,
        lastHeartbeat: now - 30000,
      },
      {
        id: 'agent-002',
        name: 'codex-default',
        type: 'codex',
        model: 'o4-mini',
        status: 'running',
        taskId: 've-760',
        taskTitle: 'feat(market): order expiry',
        branch: 've/760-market-order-expiry',
        sessionId: 'ses-002',
        index: 1,
        startedAt: now - 90 * min,
        lastHeartbeat: now - 15000,
      },
      {
        id: 'agent-003',
        name: 'copilot-claude',
        type: 'copilot',
        model: 'claude-opus-4-6',
        status: 'running',
        taskId: 've-761',
        taskTitle: 'refactor(escrow): batch settlement',
        branch: 've/761-escrow-batch',
        sessionId: 'ses-003',
        index: 2,
        startedAt: now - 45 * min,
        lastHeartbeat: now - 20000,
      },
      {
        id: 'agent-004',
        name: 'review-agent',
        type: 'codex',
        model: 'o4-mini',
        status: 'idle',
        taskId: 've-762',
        taskTitle: 'Review: veid token fix',
        branch: 've/762-veid-token-fix',
        sessionId: 'ses-004',
        index: 3,
        startedAt: now - 4 * hr,
        lastHeartbeat: now - 240000,
      },
    ];

    const SEED_LOGS = [
      { ts: now - 6*day, level: 'success', source: 'pr', msg: 'PR bosun#1 merged — fix: address three implementation gaps' },
      { ts: now - 5*day, level: 'success', source: 'pr', msg: 'PR bosun#3 merged — fix(setup): harden wizard resume' },
      { ts: now - 5*day, level: 'success', source: 'merge', msg: 'PR virtengine#745 merged — fix(security): harden TLS ✓' },
      { ts: now - 4*day, level: 'success', source: 'pr', msg: 'PR virtengine#748 merged — fix CI/CD failures' },
      { ts: now - 3*day, level: 'success', source: 'merge', msg: 'PR virtengine#751 merged — security bulk remediation ✓' },
      { ts: now - 2*day, level: 'success', source: 'merge', msg: 'PR bosun#16 merged — fix(demo): restore CDN importmap ✓' },
      { ts: now - 1*day, level: 'info', source: 'task-executor', msg: 'Routing bosun#7 feat(site): redesign → copilot-claude' },
      { ts: now - 18*hr, level: 'info', source: 'task-executor', msg: 'Routing ve#760 feat(market): order expiry → codex-default' },
      { ts: now - 12*hr, level: 'info', source: 'worktree', msg: 'Created ve/761-escrow-batch for copilot-claude' },
      { ts: now - 4*hr, level: 'info', source: 'task-executor', msg: 'Routing bosun#14 fix(ui): kanban filters → copilot-claude' },
      { ts: now - 3*hr, level: 'success', source: 'ci', msg: 'PR bosun#18 — all checks passed (test/api-integration)' },
      { ts: now - 2*hr, level: 'info', source: 'review-agent', msg: 'Reviewing PR virtengine#764 (veid token fix)...' },
      { ts: now - 1*hr, level: 'info', source: 'health', msg: 'Health check: all systems nominal' },
      { ts: now - 30*min, level: 'info', source: 'copilot', msg: 'Agent copilot-claude heartbeat — bosun#7 in progress' },
      { ts: now - 15*min, level: 'info', source: 'codex', msg: 'Agent codex-default heartbeat — ve#760 in progress' },
      { ts: now - 5*min, level: 'info', source: 'monitor', msg: 'Polling github for new tasks...' },
      { ts: now - 2*min, level: 'info', source: 'kanban', msg: 'Synced 26 tasks across bosun + virtengine' },
      { ts: now - 1*min, level: 'info', source: 'monitor', msg: 'Next poll in 60s...' },
    ];

    const SEED_HEALTH = {
      overall: 'healthy',
      components: [
        { name: 'GitHub API', status: 'ok', latency: '142ms' },
        { name: 'Telegram Bot', status: 'ok', latency: '89ms' },
        { name: 'Codex SDK', status: 'ok', latency: '234ms' },
        { name: 'Copilot SDK', status: 'ok', latency: '178ms' },
        { name: 'Shared State', status: 'ok', latency: '12ms' },
        { name: 'Worktree Manager', status: 'ok', latency: '45ms' },
      ],
    };

    const SEED_INFRA = {
      worktrees: [
        { branch: 'docs/bosun-improvement-plan', path: '/worktrees/bosun-improve', active: true, taskId: 'bosun-7' },
        { branch: 'fix/kanban-repo-filters', path: '/worktrees/kanban-filters', active: true, taskId: 'bosun-14' },
        { branch: 'test/api-integration', path: '/worktrees/api-tests', active: false, taskId: 'bosun-16' },
        { branch: 've/760-market-order-expiry', path: '/worktrees/ve-760', active: true, taskId: 've-760' },
        { branch: 've/761-escrow-batch', path: '/worktrees/ve-761', active: true, taskId: 've-761' },
        { branch: 've/762-veid-token-fix', path: '/worktrees/ve-762', active: false, taskId: 've-762' },
      ],
      containers: [],
      tunnelStatus: 'active',
      tunnelUrl: 'https://bosun-demo.trycloudflare.com',
    };

    const SEED_PROJECT = {
      name: 'bosun + virtengine',
      repo: 'virtengine/bosun',
      secondaryRepo: 'virtengine/virtengine',
      defaultBranch: 'main',
      totalTasks: SEED_TASKS.length,
      completedTasks: SEED_TASKS.filter(t => t.status === 'done').length,
      activePRs: SEED_TASKS.filter(t => t.pr && t.status !== 'done').length,
    };

    const formatTimestamp = (ts) => new Date(ts).toISOString();
    let msgCounter = 0;
    function makeMsg(role, content, ts, type, attachments) {
      msgCounter += 1;
      const msg = {
        id: `msg-${msgCounter}`,
        role,
        content,
        timestamp: formatTimestamp(ts || Date.now()),
      };
      if (type) msg.type = type;
      if (Array.isArray(attachments) && attachments.length) msg.attachments = attachments;
      return msg;
    }

    let attachmentCounter = 0;
    function makeAttachment(name, kind, contentType, size) {
      attachmentCounter += 1;
      return {
        id: `att-${attachmentCounter}`,
        name: name || 'demo-attachment.txt',
        kind: kind || 'file',
        contentType: contentType || 'text/plain',
        size: typeof size === 'number' ? size : 12 * 1024,
      };
    }

    const SESSION_MESSAGES = {
      'ses-001': [
        makeMsg('system', 'Session started for bosun-7 (feat(site): redesign landing page).', now - 2 * hr, 'system'),
        makeMsg('assistant', 'Scanning landing page layout — indexv2.html, demo.html, and CSS modules.', now - 110 * min),
        makeMsg('assistant', 'Found the demo tabs implementation. Refactoring for mobile viewport detection.', now - 80 * min),
        makeMsg('assistant', 'Added helm SVG hero section and responsive breakpoints. Running tests.', now - 40 * min),
        makeMsg('assistant', 'CI queued on PR #17. Awaiting checks.', now - 18 * min),
      ],
      'ses-002': [
        makeMsg('system', 'Session started for ve-760 (market order expiry).', now - 90 * min, 'system'),
        makeMsg('assistant', 'Reviewing x/market/keeper/order.go — existing order lifecycle hooks.', now - 80 * min),
        makeMsg('assistant', 'Implementing auto-expiry logic with configurable TTL in module params.', now - 50 * min),
        makeMsg('assistant', 'Added settlement trigger + unit tests for edge cases.', now - 20 * min),
      ],
      'ses-003': [
        makeMsg('system', 'Session started for ve-761 (escrow batch settlement).', now - 45 * min, 'system'),
        makeMsg('assistant', 'Analyzing escrow keeper batch flow. Found stubs in keeper/batch.go.', now - 35 * min),
        makeMsg('assistant', 'Drafting batch iterator and retry guard logic.', now - 15 * min),
      ],
      'ses-004': [
        makeMsg('system', 'Review session: ve-762 (veid token validation).', now - 4 * hr, 'system'),
        makeMsg('assistant', 'Reviewing PR #764 — two nits found: edge case in token refresh + lint.', now - 3 * hr),
        makeMsg('assistant', 'Requested changes on token edge case. Waiting for author fixes.', now - 2 * hr),
      ],
      'ses-005': [
        makeMsg('system', 'Session started for bosun-1 (fix implementation gaps).', now - 6 * day, 'system'),
        makeMsg('assistant', 'Fixed three gaps: setup wizard resume, GitHub flow, and config doctor.', now - 6 * day + 20 * min),
        makeMsg('assistant', 'PR #1 merged. Session archived.', now - 6 * day + 30 * min),
      ],
      'ses-006': [
        makeMsg('system', 'Session started for ve-751 (security bulk remediation).', now - 3 * day, 'system'),
        makeMsg('assistant', 'Scanning 300 CodeQL/gosec alerts across 47 modules.', now - 3 * day + 30 * min),
        makeMsg('assistant', 'Fixed 287/300 alerts. Remaining 13 are false positives — documented.', now - 3 * day + 4 * hr),
        makeMsg('assistant', 'PR #751 merged. All security checks passing.', now - 3 * day + 6 * hr),
      ],
      'ses-007': [
        makeMsg('system', 'Session: bosun-14 (kanban card repo badge + filters).', now - 4 * hr, 'system'),
        makeMsg('assistant', 'Adding repo badge to kanban cards like GitHub Projects.', now - 3 * hr),
        makeMsg('assistant', 'Implementing filter bar with Repository, Priority, Assignee dropdowns.', now - 2 * hr),
      ],
      'ses-008': [
        makeMsg('system', 'Session: ve-754 (MiniApp redesign).', now - 2 * day, 'system'),
        makeMsg('assistant', 'Redesigned mission control layout with collapsible sidebar.', now - 2 * day + 2 * hr),
        makeMsg('assistant', 'PR #754 merged after CI green.', now - 1 * day + 12 * hr),
      ],
    };

    const SEED_SESSIONS = [
      {
        id: 'ses-001',
        title: 'Landing Page Redesign',
        type: 'task',
        status: 'running',
        taskId: 'bosun-7',
        branch: 'docs/bosun-improvement-plan',
        createdAt: now - 2 * hr,
        updatedAt: now - 18 * min,
        lastMessage: 'CI queued on PR #17. Awaiting checks.',
        messages: SESSION_MESSAGES['ses-001'],
      },
      {
        id: 'ses-002',
        title: 'Market Order Expiry',
        type: 'task',
        status: 'running',
        taskId: 've-760',
        branch: 've/760-market-order-expiry',
        createdAt: now - 90 * min,
        updatedAt: now - 20 * min,
        lastMessage: 'Added settlement trigger + unit tests for edge cases.',
        messages: SESSION_MESSAGES['ses-002'],
      },
      {
        id: 'ses-003',
        title: 'Escrow Batch Settlement',
        type: 'task',
        status: 'running',
        taskId: 've-761',
        branch: 've/761-escrow-batch',
        createdAt: now - 45 * min,
        updatedAt: now - 15 * min,
        lastMessage: 'Drafting batch iterator and retry guard logic.',
        messages: SESSION_MESSAGES['ses-003'],
      },
      {
        id: 'ses-004',
        title: 'PR Review: VEID Token Fix',
        type: 'review',
        status: 'paused',
        taskId: 've-762',
        branch: 've/762-veid-token-fix',
        createdAt: now - 4 * hr,
        updatedAt: now - 2 * hr,
        lastMessage: 'Requested changes on token edge case.',
        messages: SESSION_MESSAGES['ses-004'],
      },
      {
        id: 'ses-005',
        title: 'Fix Implementation Gaps',
        type: 'task',
        status: 'archived',
        taskId: 'bosun-1',
        branch: 'copilot/assess-bosun-project-gaps',
        createdAt: now - 6 * day,
        updatedAt: now - 6 * day + 30 * min,
        lastMessage: 'PR #1 merged. Session archived.',
        messages: SESSION_MESSAGES['ses-005'],
      },
      {
        id: 'ses-006',
        title: 'Security Bulk Remediation',
        type: 'task',
        status: 'completed',
        taskId: 've-751',
        branch: 've/157-security-bulk-remediation',
        createdAt: now - 3 * day,
        updatedAt: now - 3 * day + 6 * hr,
        lastMessage: 'PR #751 merged. All security checks passing.',
        messages: SESSION_MESSAGES['ses-006'],
      },
      {
        id: 'ses-007',
        title: 'Kanban Filters + Repo Badge',
        type: 'task',
        status: 'running',
        taskId: 'bosun-14',
        branch: 'fix/kanban-repo-filters',
        createdAt: now - 4 * hr,
        updatedAt: now - 2 * hr,
        lastMessage: 'Implementing filter bar with dropdowns.',
        messages: SESSION_MESSAGES['ses-007'],
      },
      {
        id: 'ses-008',
        title: 'MiniApp Redesign',
        type: 'task',
        status: 'completed',
        taskId: 've-754',
        branch: 'feat/miniapp-redesign',
        createdAt: now - 2 * day,
        updatedAt: now - 1 * day + 12 * hr,
        lastMessage: 'PR #754 merged after CI green.',
        messages: SESSION_MESSAGES['ses-008'],
      },
    ];

    const SESSION_DIFFS = {
      'ses-001': {
        files: [
          {
            filename: 'bosun/site/indexv2.html',
            status: 'modified',
            additions: 86,
            deletions: 23,
            patch: [
              '@@ -42,12 +42,35 @@',
              ' <section class="hero">',
              '+  <div class="helm-hero">',
              '+    <svg class="helm-svg" viewBox="0 0 200 200">',
              '+      <!-- helm wheel SVG -->',
              '+    </svg>',
              '+  </div>',
              '   <h1>Bosun</h1>',
              '+  <p class="hero-subtitle">AI-powered fleet orchestration</p>',
              ' </section>',
            ].join('\n'),
          },
          {
            filename: 'bosun/ui/demo.html',
            status: 'modified',
            additions: 142,
            deletions: 67,
            patch: '@@ -260,8 +260,142 @@\n-    const SEED_TASKS = [...];\n+    // Comprehensive 1-week seed data across repos',
          },
        ],
      },
      'ses-002': {
        files: [
          {
            filename: 'x/market/keeper/order.go',
            status: 'modified',
            additions: 47,
            deletions: 12,
            patch: [
              '@@ -118,6 +118,42 @@',
              ' func (k Keeper) ProcessOrder(ctx sdk.Context, order Order) error {',
              '+    // Check expiry TTL from module params',
              '+    if order.ExpiresAt.Before(ctx.BlockTime()) {',
              '+        k.CancelOrder(ctx, order.Id)',
              '+        return ErrOrderExpired',
              '+    }',
              '+    // Auto-settlement on expiry if has matching counterpart',
              '+    if k.HasMatchingOrder(ctx, order) {',
              '+        return k.SettleOrder(ctx, order)',
              '+    }',
              '     return nil',
              ' }',
            ].join('\n'),
          },
          {
            filename: 'x/market/keeper/order_test.go',
            status: 'added',
            additions: 89,
            deletions: 0,
            patch: '@@ -0,0 +1,89 @@\n+package keeper_test\n+\n+func TestOrderExpiry(t *testing.T) {\n+    // ... test cases\n+}',
          },
        ],
      },
      'ses-003': {
        files: [
          {
            filename: 'x/escrow/keeper/batch.go',
            status: 'added',
            additions: 42,
            deletions: 0,
            patch: [
              '@@ -0,0 +1,42 @@',
              '+package keeper',
              '+',
              '+// BatchSettle processes pending settlements in batch.',
              '+func (k Keeper) BatchSettle(ctx sdk.Context) error {',
              '+    iter := k.store.Iterator(ctx, k.settlementPrefix)',
              '+    defer iter.Close()',
              '+',
              '+    for ; iter.Valid(); iter.Next() {',
              '+        // settle',
              '+    }',
              '+    return nil',
              '+}',
            ].join('\n'),
          },
          {
            filename: 'x/escrow/keeper/msg_server.go',
            status: 'modified',
            additions: 9,
            deletions: 2,
            patch: [
              '@@ -118,6 +118,13 @@',
              ' func (s msgServer) TriggerSettlement(...) {',
              '+    if err := s.Keeper.BatchSettle(ctx); err != nil {',
              '+        return nil, err',
              '+    }',
              '     return &types.MsgTriggerSettlementResponse{}, nil',
              ' }',
            ].join('\n'),
          },
        ],
      },
      'ses-004': {
        files: [
          {
            filename: 'x/veid/keeper/token.go',
            status: 'modified',
            additions: 18,
            deletions: 5,
            patch: [
              '@@ -44,8 +44,22 @@',
              '-func (k Keeper) ValidateToken(ctx sdk.Context, token string) error {',
              '+func (k Keeper) ValidateToken(ctx sdk.Context, token string) error {',
              '+    if token == "" {',
              '+        return ErrEmptyToken',
              '+    }',
              '+    // Refresh check',
              '+    if k.IsExpired(ctx, token) {',
              '+        return k.RefreshToken(ctx, token)',
              '+    }',
              '+    return nil',
              '+}',
            ].join('\n'),
          },
        ],
      },
      'ses-005': { files: [] },
      'ses-006': {
        files: [
          {
            filename: '47 files across x/ and app/ modules',
            status: 'modified',
            additions: 892,
            deletions: 341,
            patch: '@@ Security bulk remediation — 287/300 alerts fixed\n+Replaced math/rand with crypto/rand\n+Fixed file path traversal\n+Hardened TLS configs',
          },
        ],
      },
      'ses-007': {
        files: [
          {
            filename: 'bosun/ui/components/kanban-board.js',
            status: 'modified',
            additions: 124,
            deletions: 18,
            patch: '@@ -1,5 +1,5 @@\n-Kanban Board Component — Trello-style\n+Kanban Board Component — GitHub Projects-style\n+// Added repo badge, filter bar, and assignee display',
          },
          {
            filename: 'bosun/ui/styles/kanban.css',
            status: 'modified',
            additions: 156,
            deletions: 3,
            patch: '@@ Added filter bar, repo badge, dropdown styles',
          },
        ],
      },
      'ses-008': { files: [] },
    };

    /* ── Internal State (mutable — actions modify this in-place) ──── */
    const STATE = {
      tasks: SEED_TASKS,
      status: SEED_STATUS,
      executors: SEED_EXECUTORS,
      agents: SEED_AGENTS,
      logs: SEED_LOGS,
      health: SEED_HEALTH,
      infra: SEED_INFRA,
      project: SEED_PROJECT,
      paused: false,
      maxParallel: 6,
      settings: {
        maxParallel: 6,
        executorMode: 'internal',
        autoMerge: true,
        autoRebase: true,
        reviewAgent: true,
        sentinelEnabled: false,
        sdk: 'auto',
        region: 'auto',
      },
      sessions: SEED_SESSIONS,
      sessionDiffs: SESSION_DIFFS,
      worktrees: [
        { branch: 'docs/bosun-improvement-plan', path: '/worktrees/bs-improvement', active: true, taskId: 'bosun-7' },
        { branch: 've/751-security-bulk-remediation', path: '/worktrees/ve-751', active: false, taskId: 've-751' },
        { branch: 'bs/12-error-correlation', path: '/worktrees/bs-12', active: true, taskId: 'bosun-12' },
        { branch: 'bs/11-agent-logging-enrich', path: '/worktrees/bs-11', active: true, taskId: 'bosun-11' },
        { branch: 've/760-market-order-expiry', path: '/worktrees/ve-760', active: true, taskId: 've-760' },
        { branch: 've/761-escrow-batch', path: '/worktrees/ve-761', active: true, taskId: 've-761' },
      ],
      managedWorkspaces: [
        {
          id: 'ws-multi',
          name: 'virtengine-workspace',
          path: '/home/demo/repos/virtengine-workspace',
          active: true,
          repos: [
            { name: 'bosun', url: 'https://github.com/virtengine/bosun.git', branch: 'main', primary: true },
            { name: 'virtengine', url: 'https://github.com/virtengine/virtengine.git', branch: 'main', primary: false },
          ],
          createdAt: now - 30 * 24 * hr,
        },
      ],
      activeWorkspaceId: 'ws-multi',
      sharedWorkspaces: [
        { id: 'sw-1', name: 'bosun-dev', claimedBy: 'copilot-claude', claimedAt: now - 1 * hr, expiresAt: now + 1 * hr },
        { id: 'sw-2', name: 'virtengine-dev', claimedBy: 'codex-sdk', claimedAt: now - 30 * min, expiresAt: now + 90 * min },
      ],
      agentMode: 'agent',
      activeAgentId: 'codex-sdk',
      availableAgents: [
        { id: 'codex-sdk', name: 'Codex SDK', provider: 'openai', available: true, busy: false, capabilities: ['code', 'test', 'refactor'] },
        { id: 'copilot-claude', name: 'Copilot Claude', provider: 'anthropic', available: true, busy: false, capabilities: ['code', 'review', 'plan'] },
        { id: 'codex-mini', name: 'Codex Mini', provider: 'openai', available: true, busy: false, capabilities: ['code'] },
      ],
      libraryEntries: [],
      libraryContents: {},
      gitBranches: [
        'main',
        'docs/bosun-improvement-plan',
        've/751-security-bulk-remediation',
        've/760-market-order-expiry',
        've/761-escrow-batch',
        've/762-veid-token-fix',
        'bs/12-error-correlation',
        'bs/11-agent-logging-enrich',
        'bs/13-weekly-report',
        'fix/kanban-repo-filters',
      ],
      gitDiff: '--- a/bosun/ui/components/kanban-board.js\n+++ b/bosun/ui/components/kanban-board.js\n@@ -1,5 +1,8 @@\n-// Kanban Board Component — Trello-style\n+// Kanban Board Component — GitHub Projects-style\n+import { useState } from \"preact/hooks\";\n+\n+function getTaskRepo(task) { ... }\n+function KanbanFilter({ tasks, filters, onFilterChange }) { ... }',
      agentLogFiles: ['copilot-claude-42.log', 'codex-default-43.log', 'monitor.log'],
      presence: {
        instances: [{ id: 'inst-1', host: 'dev-machine', pid: 12345, started: now - 3 * hr, role: 'primary' }],
        coordinator: { id: 'inst-1', host: 'dev-machine', elected: now - 3 * hr },
      },
      // ── Workflow data — fully wired demo workflows ──
      workflows: [
        // ─── 1. PR Merge Strategy (github) — 14 nodes, 21 edges ───
        {
          id: 'wf-pr-merge-auto',
          name: 'PR Merge Strategy',
          description: 'Automated PR merge decision: analyze diffs, CI status, and agent output. Decides: merge, prompt, re-attempt, close, escalate, or wait.',
          category: 'github',
          enabled: true,
          nodeCount: 14,
          trigger: 'trigger.pr_event',
          nodes: [
            { id: 'trigger',          type: 'trigger.pr_event',       label: 'PR Ready for Review',   config: { event: 'review_requested' },                              position: { x: 400, y: 50 } },
            { id: 'check-ci',         type: 'validation.build',       label: 'Check CI Status',       config: { command: 'gh pr checks --json name,state' },    position: { x: 150, y: 200 } },
            { id: 'get-diff',         type: 'action.run_command',     label: 'Get Diff Stats',        config: { command: 'git diff --stat main...HEAD' },                  position: { x: 650, y: 200 } },
            { id: 'ci-passed',        type: 'condition.expression',   label: 'CI Passed?',            config: { expression: "$ctx.getNodeOutput('check-ci')?.passed" },    position: { x: 150, y: 350 } },
            { id: 'wait-for-ci',      type: 'action.delay',           label: 'Wait for CI',           config: { delayMs: 300000, reason: 'CI still running' },             position: { x: 150, y: 500 } },
            { id: 'analyze',          type: 'action.run_agent',       label: 'Analyze Merge Strategy',config: { prompt: 'Review PR and decide: merge, prompt, close, re_attempt, manual_review, wait, or noop.', timeoutMs: 900000 }, position: { x: 400, y: 350 } },
            { id: 'decision-router',  type: 'condition.switch',       label: 'Route Decision',        config: { field: 'action', cases: { merge_after_ci_pass: 'merge', prompt: 'prompt-agent', close_pr: 'close', re_attempt: 'retry', manual_review: 'escalate', wait: 'wait-for-ci' } }, position: { x: 400, y: 520 } },
            { id: 'do-merge',         type: 'action.run_command',     label: 'Auto-Merge PR',         config: { command: 'gh pr merge --auto --squash' },                  position: { x: 100, y: 680 } },
            { id: 'do-prompt',        type: 'action.run_agent',       label: 'Prompt Agent',          config: { prompt: 'Continue working. Instructions: {{decision.message}}' }, position: { x: 300, y: 680 } },
            { id: 'do-close',         type: 'action.run_command',     label: 'Close PR',              config: { command: 'gh pr close --comment "{{decision.reason}}"' },   position: { x: 500, y: 680 } },
            { id: 'do-retry',         type: 'action.run_agent',       label: 'Re-attempt Task',       config: { prompt: 'Start over: {{decision.reason}}' },               position: { x: 700, y: 680 } },
            { id: 'do-escalate',      type: 'notify.telegram',        label: 'Escalate to Human',     config: { message: ':eye: PR needs manual review: {{decision.reason}}' }, position: { x: 900, y: 680 } },
            { id: 'notify-complete',  type: 'notify.log',             label: 'Log Result',            config: { message: 'PR merge strategy: {{decision.action}}', level: 'info' }, position: { x: 400, y: 850 } },
          ],
          edges: [
            { id: 'e1',  source: 'trigger',         target: 'check-ci' },
            { id: 'e2',  source: 'trigger',         target: 'get-diff' },
            { id: 'e3',  source: 'check-ci',        target: 'ci-passed' },
            { id: 'e4',  source: 'ci-passed',       target: 'wait-for-ci',     condition: 'CI not passed' },
            { id: 'e5',  source: 'ci-passed',       target: 'analyze',         condition: 'CI passed' },
            { id: 'e6',  source: 'get-diff',        target: 'analyze' },
            { id: 'e7',  source: 'wait-for-ci',     target: 'analyze' },
            { id: 'e8',  source: 'analyze',         target: 'decision-router' },
            { id: 'e9',  source: 'decision-router', target: 'do-merge',        condition: 'merge' },
            { id: 'e10', source: 'decision-router', target: 'do-prompt',       condition: 'prompt' },
            { id: 'e11', source: 'decision-router', target: 'do-close',        condition: 'close' },
            { id: 'e12', source: 'decision-router', target: 'do-retry',        condition: 'retry' },
            { id: 'e13', source: 'decision-router', target: 'do-escalate',     condition: 'escalate' },
            { id: 'e14', source: 'decision-router', target: 'wait-for-ci',     condition: 'wait' },
            { id: 'e15', source: 'do-merge',        target: 'notify-complete' },
            { id: 'e16', source: 'do-prompt',       target: 'notify-complete' },
            { id: 'e17', source: 'do-close',        target: 'notify-complete' },
            { id: 'e18', source: 'do-retry',        target: 'notify-complete' },
            { id: 'e19', source: 'do-escalate',     target: 'notify-complete' },
          ],
          variables: { baseBranch: 'main', ciTimeoutMs: 300000, cooldownSec: 60, maxRetries: 3 },
          metadata: { createdAt: new Date(now - 7 * 24 * hr).toISOString(), updatedAt: new Date(now - 1 * hr).toISOString() },
        },
        // ─── 2. Review Agent (github) — 6 nodes, 6 edges ───
        {
          id: 'wf-review-agent',
          name: 'Review Agent',
          description: 'Auto code review on PR: parallel build + tests, then AI analysis, aggregate, and post.',
          category: 'github',
          enabled: true,
          nodeCount: 6,
          trigger: 'trigger.pr_event',
          nodes: [
            { id: 'trigger',   type: 'trigger.pr_event',    label: 'PR Opened/Updated', config: { event: 'opened' },                               position: { x: 400, y: 50 } },
            { id: 'run-build', type: 'validation.build',    label: 'Run Build',         config: { command: 'npm run build' },                       position: { x: 200, y: 200 } },
            { id: 'run-tests', type: 'validation.tests',    label: 'Run Tests',         config: { command: 'npm test' },                            position: { x: 600, y: 200 } },
            { id: 'run-review',type: 'action.run_agent',    label: 'Agent Review',      config: { prompt: 'Review changes for quality, bugs, test coverage, and docs.', timeoutMs: 900000 }, position: { x: 400, y: 350 } },
            { id: 'aggregate', type: 'transform.aggregate', label: 'Collect Results',   config: { sources: ['run-build', 'run-tests', 'run-review'] }, position: { x: 400, y: 500 } },
            { id: 'notify',    type: 'notify.telegram',     label: 'Post Review',       config: { message: ':edit: PR review complete for {{branch}}' }, position: { x: 400, y: 640 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger',    target: 'run-build' },
            { id: 'e2', source: 'trigger',    target: 'run-tests' },
            { id: 'e3', source: 'run-build',  target: 'run-review' },
            { id: 'e4', source: 'run-tests',  target: 'run-review' },
            { id: 'e5', source: 'run-review', target: 'aggregate' },
            { id: 'e6', source: 'aggregate',  target: 'notify' },
          ],
          variables: {},
          metadata: { createdAt: new Date(now - 6 * 24 * hr).toISOString(), updatedAt: new Date(now - 3 * hr).toISOString() },
        },
        // ─── 3. Error Recovery (reliability) — 5 nodes, 4 edges ───
        {
          id: 'wf-error-recovery',
          name: 'Error Recovery',
          description: 'Auto-fix after agent crash — analyze logs, retry with fix, escalate if exhausted.',
          category: 'reliability',
          enabled: true,
          nodeCount: 5,
          trigger: 'trigger.event',
          nodes: [
            { id: 'trigger',       type: 'trigger.event',          label: 'Agent Failed',      config: { eventType: 'task.failed' },                               position: { x: 400, y: 50 } },
            { id: 'check-retries', type: 'condition.expression',   label: 'Retries Left?',     config: { expression: '($data?.retryCount || 0) < ($data?.maxRetries || 3)' }, position: { x: 400, y: 180 } },
            { id: 'analyze-error', type: 'action.run_agent',       label: 'Analyze Failure',   config: { prompt: 'Analyze this error and suggest a fix:\n{{lastError}}\nTask: {{taskTitle}}', timeoutMs: 300000 }, position: { x: 200, y: 330 } },
            { id: 'retry-task',    type: 'action.run_agent',       label: 'Retry Task',        config: { prompt: '{{taskExecutorRetryPrompt}}', timeoutMs: 3600000 }, position: { x: 200, y: 480 } },
            { id: 'escalate',      type: 'notify.telegram',        label: 'Escalate to Human', config: { message: ':alert: Task {{taskTitle}} failed after {{maxRetries}} attempts. Manual intervention needed.' }, position: { x: 600, y: 180 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger',       target: 'check-retries' },
            { id: 'e2', source: 'check-retries', target: 'analyze-error',  condition: 'retries > 0' },
            { id: 'e3', source: 'check-retries', target: 'escalate',       condition: 'retries == 0' },
            { id: 'e4', source: 'analyze-error', target: 'retry-task' },
          ],
          variables: { maxRetries: 3 },
          metadata: { createdAt: new Date(now - 5 * 24 * hr).toISOString(), updatedAt: new Date(now - 2 * hr).toISOString() },
        },
        // ─── 4. Build & Deploy (ci-cd) — 6 nodes, 5 edges ───
        {
          id: 'wf-build-deploy',
          name: 'Build & Deploy',
          description: 'CI/CD pipeline: build → test → lint → deploy → notify. Triggered on PR merge to main.',
          category: 'ci-cd',
          enabled: false,
          nodeCount: 6,
          trigger: 'trigger.event',
          nodes: [
            { id: 'trigger', type: 'trigger.event',       label: 'PR Merged to Main', config: { eventType: 'pr.merged', filter: "$event.branch === 'main'" }, position: { x: 400, y: 50 } },
            { id: 'build',   type: 'validation.build',    label: 'Build',             config: { command: 'npm run build', zeroWarnings: true },               position: { x: 400, y: 180 } },
            { id: 'test',    type: 'validation.tests',    label: 'Tests',             config: { command: 'npm test' },                                        position: { x: 400, y: 310 } },
            { id: 'lint',    type: 'validation.lint',     label: 'Lint',              config: { command: 'npm run lint' },                                     position: { x: 400, y: 440 } },
            { id: 'deploy',  type: 'action.run_command',  label: 'Deploy',            config: { command: 'npm run deploy' },                                   position: { x: 400, y: 570 } },
            { id: 'notify',  type: 'notify.telegram',     label: 'Notify Deploy',     config: { message: ':rocket: Deployment to production completed for {{branch}}' }, position: { x: 400, y: 700 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'build' },
            { id: 'e2', source: 'build',   target: 'test' },
            { id: 'e3', source: 'test',    target: 'lint' },
            { id: 'e4', source: 'lint',    target: 'deploy' },
            { id: 'e5', source: 'deploy',  target: 'notify' },
          ],
          variables: { deployCommand: 'npm run deploy', deployBranch: 'main' },
          metadata: { createdAt: new Date(now - 4 * 24 * hr).toISOString(), updatedAt: new Date(now - 5 * hr).toISOString() },
        },
        // ─── 5. Task Planner (planning) — 7 nodes, 7 edges ───
        {
          id: 'wf-task-planner',
          name: 'Task Planner',
          description: 'Auto-replenish backlog: monitor task count, spawn planner agent when low, create tasks, notify.',
          category: 'planning',
          enabled: true,
          nodeCount: 7,
          trigger: 'trigger.cron',
          nodes: [
            { id: 'trigger',     type: 'trigger.cron',           label: 'Every 30 min',       config: { cron: '*/30 * * * *' },                                    position: { x: 400, y: 50 } },
            { id: 'count-tasks', type: 'action.run_command',     label: 'Count Open Tasks',   config: { command: 'bosun task list --status todo --count' },          position: { x: 400, y: 180 } },
            { id: 'check-low',   type: 'condition.expression',   label: 'Tasks Low?',         config: { expression: '$data?.count < 3' },                           position: { x: 400, y: 310 } },
            { id: 'plan-tasks',  type: 'action.run_agent',       label: 'Plan New Tasks',     config: { prompt: 'Review the codebase and create 3-5 actionable improvement tasks.', timeoutMs: 600000 }, position: { x: 200, y: 460 } },
            { id: 'create-tasks',type: 'action.run_command',     label: 'Create Tasks',       config: { command: 'bosun task create --from-plan' },                 position: { x: 200, y: 610 } },
            { id: 'notify',      type: 'notify.telegram',        label: 'Notify Planner Done',config: { message: ':clipboard: Task planner added new tasks to backlog' },    position: { x: 200, y: 760 } },
            { id: 'skip',        type: 'notify.log',             label: 'Backlog OK',         config: { message: 'Backlog has enough tasks, skipping', level: 'debug' }, position: { x: 600, y: 460 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger',      target: 'count-tasks' },
            { id: 'e2', source: 'count-tasks',  target: 'check-low' },
            { id: 'e3', source: 'check-low',    target: 'plan-tasks',   condition: 'count < 3' },
            { id: 'e4', source: 'check-low',    target: 'skip',         condition: 'count >= 3' },
            { id: 'e5', source: 'plan-tasks',   target: 'create-tasks' },
            { id: 'e6', source: 'create-tasks', target: 'notify' },
          ],
          variables: { minTaskThreshold: 3, planCount: 5 },
          metadata: { createdAt: new Date(now - 3 * 24 * hr).toISOString(), updatedAt: new Date(now - 4 * hr).toISOString() },
        },
        // ─── 6. Frontend Agent (agents) — 8 nodes, 9 edges ───
        {
          id: 'wf-frontend-agent',
          name: 'Frontend Agent',
          description: 'Frontend dev agent: implement UI changes, run build + lint, take screenshots, verify with model review.',
          category: 'agents',
          enabled: true,
          nodeCount: 8,
          trigger: 'trigger.task_assigned',
          nodes: [
            { id: 'trigger',         type: 'trigger.task_assigned', label: 'Task Assigned',      config: { agentType: 'frontend' },                                     position: { x: 400, y: 50 } },
            { id: 'run-agent',       type: 'action.run_agent',      label: 'Run Frontend Agent', config: { prompt: 'Implement frontend changes for: {{taskTitle}}', timeoutMs: 7200000 }, position: { x: 400, y: 200 } },
            { id: 'verify-build',    type: 'validation.build',      label: 'Verify Build',       config: { command: 'npm run build', zeroWarnings: true },                position: { x: 200, y: 350 } },
            { id: 'verify-lint',     type: 'validation.lint',       label: 'Verify Lint',        config: { command: 'npm run lint' },                                     position: { x: 600, y: 350 } },
            { id: 'screenshot',      type: 'action.run_command',    label: 'Take Screenshots',   config: { command: 'bosun screenshot --viewport desktop,mobile' },       position: { x: 400, y: 500 } },
            { id: 'model-review',    type: 'action.run_agent',      label: 'Model Verification', config: { prompt: 'Verify screenshots match task requirements. Pass/fail.', timeoutMs: 300000 }, position: { x: 400, y: 650 } },
            { id: 'mark-done',       type: 'action.update_task_status', label: 'Mark Done',      config: { status: 'done' },                                              position: { x: 200, y: 800 } },
            { id: 'notify-fail',     type: 'notify.telegram',       label: 'Notify Failed',      config: { message: ':close: Frontend verification failed for {{taskTitle}}' }, position: { x: 600, y: 800 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger',      target: 'run-agent' },
            { id: 'e2', source: 'run-agent',    target: 'verify-build' },
            { id: 'e3', source: 'run-agent',    target: 'verify-lint' },
            { id: 'e4', source: 'verify-build', target: 'screenshot' },
            { id: 'e5', source: 'verify-lint',  target: 'screenshot' },
            { id: 'e6', source: 'screenshot',   target: 'model-review' },
            { id: 'e7', source: 'model-review', target: 'mark-done',   condition: 'passed' },
            { id: 'e8', source: 'model-review', target: 'notify-fail', condition: 'failed' },
          ],
          variables: { devServerUrl: 'http://localhost:3000', evidenceDir: '.bosun/evidence' },
          metadata: { createdAt: new Date(now - 2 * 24 * hr).toISOString(), updatedAt: new Date(now - 30 * 60000).toISOString() },
        },
      ],
      workflowTemplates: [
        {
          id: 'template-pr-merge-strategy', name: 'PR Merge Strategy', description: 'Automated PR merge decision workflow with 7 outcome paths.', category: 'github', categoryLabel: 'GitHub', categoryIcon: ':git:', categoryOrder: 1, tags: ['github', 'pr', 'merge', 'strategy'], nodeCount: 14, edgeCount: 16, recommended: true,
          nodes: [
            { id: 'trigger', type: 'trigger.pr_event', label: 'PR Ready for Review', config: { event: 'review_requested' }, position: { x: 400, y: 50 } },
            { id: 'check-ci', type: 'validation.build', label: 'Check CI Status', config: { command: 'gh pr checks' }, position: { x: 150, y: 200 } },
            { id: 'get-diff', type: 'action.run_command', label: 'Get Diff Stats', config: { command: 'git diff --stat main...HEAD' }, position: { x: 650, y: 200 } },
            { id: 'ci-passed', type: 'condition.expression', label: 'CI Passed?', config: { expression: '$data?.ciPassed === true', trueLabel: 'passed', falseLabel: 'pending' }, position: { x: 150, y: 350 } },
            { id: 'wait-for-ci', type: 'action.delay', label: 'Wait for CI', config: { delayMs: 300000 }, position: { x: 150, y: 500 } },
            { id: 'analyze', type: 'action.run_agent', label: 'Analyze Merge', config: { prompt: 'Decide: merge, prompt, close, retry, escalate, wait, noop' }, position: { x: 400, y: 350 } },
            { id: 'decision-router', type: 'condition.switch', label: 'Route Decision', config: { field: 'action' }, position: { x: 400, y: 520 } },
            { id: 'do-merge', type: 'action.run_command', label: 'Auto-Merge', config: { command: 'gh pr merge --auto --squash' }, position: { x: 100, y: 680 } },
            { id: 'do-prompt', type: 'action.run_agent', label: 'Prompt Agent', config: { prompt: 'Address the reviewer feedback on this PR. Fix the issues identified and push updated commits.', sdk: 'auto' }, position: { x: 300, y: 680 } },
            { id: 'do-close', type: 'action.run_command', label: 'Close PR', config: { command: 'gh pr close' }, position: { x: 500, y: 680 } },
            { id: 'do-retry', type: 'action.run_agent', label: 'Re-attempt', config: { prompt: 'Re-attempt the implementation from scratch. The previous approach had issues. Start fresh on a new branch.', sdk: 'auto' }, position: { x: 700, y: 680 } },
            { id: 'do-escalate', type: 'notify.telegram', label: 'Escalate', config: { message: ':alert: PR needs manual review — auto-merge could not decide. Please review and merge manually.' }, position: { x: 900, y: 680 } },
            { id: 'notify-complete', type: 'notify.log', label: 'Log Result', config: { message: 'PR merge decision workflow completed', level: 'info' }, position: { x: 400, y: 850 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'check-ci' }, { id: 'e2', source: 'trigger', target: 'get-diff' },
            { id: 'e3', source: 'check-ci', target: 'ci-passed' }, { id: 'e4', source: 'ci-passed', target: 'wait-for-ci', condition: 'CI not passed' },
            { id: 'e5', source: 'ci-passed', target: 'analyze', condition: 'CI passed' }, { id: 'e6', source: 'get-diff', target: 'analyze' },
            { id: 'e7', source: 'wait-for-ci', target: 'analyze' }, { id: 'e8', source: 'analyze', target: 'decision-router' },
            { id: 'e9', source: 'decision-router', target: 'do-merge', condition: 'merge' }, { id: 'e10', source: 'decision-router', target: 'do-prompt', condition: 'prompt' },
            { id: 'e11', source: 'decision-router', target: 'do-close', condition: 'close' }, { id: 'e12', source: 'decision-router', target: 'do-retry', condition: 'retry' },
            { id: 'e13', source: 'decision-router', target: 'do-escalate', condition: 'escalate' },
            { id: 'e14', source: 'do-merge', target: 'notify-complete' }, { id: 'e15', source: 'do-prompt', target: 'notify-complete' },
            { id: 'e16', source: 'do-close', target: 'notify-complete' }, { id: 'e17', source: 'do-retry', target: 'notify-complete' },
            { id: 'e18', source: 'do-escalate', target: 'notify-complete' },
          ],
        },
        {
          id: 'template-pr-triage', name: 'PR Triage & Labels', description: 'Auto-classify PRs by size, detect breaking changes, assign labels.', category: 'github', categoryLabel: 'GitHub', categoryIcon: ':git:', categoryOrder: 1, tags: ['github', 'pr', 'triage', 'labels'], nodeCount: 11, edgeCount: 12,
          nodes: [
            { id: 'trigger', type: 'trigger.pr_event', label: 'PR Opened', config: { event: 'opened' }, position: { x: 400, y: 50 } },
            { id: 'get-stats', type: 'action.run_command', label: 'Get PR Stats', config: { command: 'gh pr view --json additions,deletions' }, position: { x: 400, y: 180 } },
            { id: 'classify-size', type: 'condition.switch', label: 'Classify Size', config: { field: 'totalChanges' }, position: { x: 400, y: 330 } },
            { id: 'label-small', type: 'action.run_command', label: 'Label: Size/S', config: { command: 'gh pr edit --add-label "size/S"' }, position: { x: 150, y: 480 } },
            { id: 'label-medium', type: 'action.run_command', label: 'Label: Size/M', config: { command: 'gh pr edit --add-label "size/M"' }, position: { x: 400, y: 480 } },
            { id: 'label-large', type: 'action.run_command', label: 'Label: Size/L', config: { command: 'gh pr edit --add-label "size/L"' }, position: { x: 650, y: 480 } },
            { id: 'detect-breaking', type: 'action.run_agent', label: 'Detect Breaking', config: { prompt: 'Analyze diff for breaking changes' }, position: { x: 400, y: 630 } },
            { id: 'is-breaking', type: 'condition.expression', label: 'Breaking?', config: { expression: '$data?.hasBreakingChanges === true', trueLabel: 'breaking', falseLabel: 'safe' }, position: { x: 400, y: 780 } },
            { id: 'label-breaking', type: 'action.run_command', label: 'Label: Breaking', config: { command: 'gh pr edit --add-label "breaking-change"' }, position: { x: 200, y: 920 } },
            { id: 'done', type: 'notify.log', label: 'Triage Complete', config: { message: 'PR triage and labeling complete', level: 'info' }, position: { x: 400, y: 1050 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'get-stats' }, { id: 'e2', source: 'get-stats', target: 'classify-size' },
            { id: 'e3', source: 'classify-size', target: 'label-small', condition: 'small' }, { id: 'e4', source: 'classify-size', target: 'label-medium', condition: 'medium' },
            { id: 'e5', source: 'classify-size', target: 'label-large', condition: 'large' },
            { id: 'e6', source: 'label-small', target: 'detect-breaking' }, { id: 'e7', source: 'label-medium', target: 'detect-breaking' },
            { id: 'e8', source: 'label-large', target: 'detect-breaking' }, { id: 'e9', source: 'detect-breaking', target: 'is-breaking' },
            { id: 'e10', source: 'is-breaking', target: 'label-breaking', condition: 'breaking' }, { id: 'e11', source: 'is-breaking', target: 'done', condition: 'not breaking' },
            { id: 'e12', source: 'label-breaking', target: 'done' },
          ],
        },
        {
          id: 'template-review-agent', name: 'Review Agent', description: 'Automated PR code review: build, test, agent analysis.', category: 'github', categoryLabel: 'GitHub', categoryIcon: ':git:', categoryOrder: 1, tags: ['github', 'review', 'pr'], nodeCount: 6, edgeCount: 6, recommended: true,
          nodes: [
            { id: 'trigger', type: 'trigger.pr_event', label: 'PR Opened', config: { event: 'opened' }, position: { x: 400, y: 50 } },
            { id: 'run-build', type: 'validation.build', label: 'Run Build', config: { command: 'npm run build' }, position: { x: 200, y: 200 } },
            { id: 'run-tests', type: 'validation.tests', label: 'Run Tests', config: { command: 'npm test' }, position: { x: 600, y: 200 } },
            { id: 'run-review', type: 'action.run_agent', label: 'Agent Review', config: { prompt: 'Review for quality, bugs, coverage, docs.' }, position: { x: 400, y: 350 } },
            { id: 'aggregate', type: 'transform.aggregate', label: 'Collect Results', config: { sourceNodes: 'run-build,run-tests,run-review', outputField: 'reviewResults' }, position: { x: 400, y: 500 } },
            { id: 'notify', type: 'notify.telegram', label: 'Post Review', config: { message: ':edit: PR review complete' }, position: { x: 400, y: 640 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'run-build' }, { id: 'e2', source: 'trigger', target: 'run-tests' },
            { id: 'e3', source: 'run-build', target: 'run-review' }, { id: 'e4', source: 'run-tests', target: 'run-review' },
            { id: 'e5', source: 'run-review', target: 'aggregate' }, { id: 'e6', source: 'aggregate', target: 'notify' },
          ],
        },
        {
          id: 'template-frontend-agent', name: 'Frontend Agent', description: 'Front-end dev agent with screenshot validation.', category: 'agents', categoryLabel: 'Agents', categoryIcon: ':bot:', categoryOrder: 2, tags: ['agent', 'frontend', 'screenshot'], nodeCount: 8, edgeCount: 9,
          nodes: [
            { id: 'trigger', type: 'trigger.task_assigned', label: 'Task Assigned', config: { agentType: 'frontend' }, position: { x: 400, y: 50 } },
            { id: 'run-agent', type: 'action.run_agent', label: 'Run Frontend Agent', config: { prompt: 'Implement: {{taskTitle}}' }, position: { x: 400, y: 200 } },
            { id: 'verify-build', type: 'validation.build', label: 'Verify Build', config: { command: 'npm run build' }, position: { x: 200, y: 350 } },
            { id: 'verify-lint', type: 'validation.lint', label: 'Verify Lint', config: { command: 'npm run lint' }, position: { x: 600, y: 350 } },
            { id: 'screenshot', type: 'action.run_command', label: 'Screenshots', config: { command: 'bosun screenshot' }, position: { x: 400, y: 500 } },
            { id: 'model-review', type: 'action.run_agent', label: 'Model Review', config: { prompt: 'Verify screenshots match requirements' }, position: { x: 400, y: 650 } },
            { id: 'mark-done', type: 'action.update_task_status', label: 'Mark Done', config: { status: 'done' }, position: { x: 200, y: 800 } },
            { id: 'notify-fail', type: 'notify.telegram', label: 'Notify Failed', config: { message: ':close: Verification failed' }, position: { x: 600, y: 800 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'run-agent' }, { id: 'e2', source: 'run-agent', target: 'verify-build' },
            { id: 'e3', source: 'run-agent', target: 'verify-lint' }, { id: 'e4', source: 'verify-build', target: 'screenshot' },
            { id: 'e5', source: 'verify-lint', target: 'screenshot' }, { id: 'e6', source: 'screenshot', target: 'model-review' },
            { id: 'e7', source: 'model-review', target: 'mark-done', condition: 'passed' },
            { id: 'e8', source: 'model-review', target: 'notify-fail', condition: 'failed' },
          ],
        },
        {
          id: 'template-task-planner', name: 'Task Planner', description: 'Auto-replenish backlog when tasks run low.', category: 'planning', categoryLabel: 'Planning', categoryIcon: ':clipboard:', categoryOrder: 3, tags: ['planning', 'backlog'], nodeCount: 7, edgeCount: 7, recommended: true,
          nodes: [
            { id: 'trigger', type: 'trigger.cron', label: 'Every 30 min', config: { cron: '*/30 * * * *' }, position: { x: 400, y: 50 } },
            { id: 'count-tasks', type: 'action.run_command', label: 'Count Tasks', config: { command: 'bosun task list --status todo --count' }, position: { x: 400, y: 180 } },
            { id: 'check-low', type: 'condition.expression', label: 'Tasks Low?', config: { expression: '$data?.count < 3' }, position: { x: 400, y: 310 } },
            { id: 'plan-tasks', type: 'action.run_agent', label: 'Plan New Tasks', config: { prompt: 'Create 3-5 improvement tasks' }, position: { x: 200, y: 460 } },
            { id: 'create-tasks', type: 'action.run_command', label: 'Create Tasks', config: { command: 'bosun task import --from-plan', timeoutMs: 60000 }, position: { x: 200, y: 610 } },
            { id: 'notify', type: 'notify.telegram', label: 'Notify Done', config: { message: ':clipboard: Tasks replenished' }, position: { x: 200, y: 760 } },
            { id: 'skip', type: 'notify.log', label: 'Backlog OK', config: { message: 'Backlog has enough tasks — skipping replenishment', level: 'info' }, position: { x: 600, y: 460 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'count-tasks' }, { id: 'e2', source: 'count-tasks', target: 'check-low' },
            { id: 'e3', source: 'check-low', target: 'plan-tasks', condition: 'low' }, { id: 'e4', source: 'check-low', target: 'skip', condition: 'ok' },
            { id: 'e5', source: 'plan-tasks', target: 'create-tasks' }, { id: 'e6', source: 'create-tasks', target: 'notify' },
          ],
        },
        {
          id: 'template-task-replenish', name: 'Task Replenish', description: 'Periodic task replenishment on cron schedule.', category: 'planning', categoryLabel: 'Planning', categoryIcon: ':clipboard:', categoryOrder: 3, tags: ['planning', 'cron'], nodeCount: 7, edgeCount: 6,
          nodes: [
            { id: 'trigger', type: 'trigger.cron', label: 'Cron Schedule', config: { cron: '0 */6 * * *' }, position: { x: 400, y: 50 } },
            { id: 'scan', type: 'action.run_command', label: 'Scan Backlog', config: { command: 'bosun task list --status todo --json', timeoutMs: 30000 }, position: { x: 400, y: 180 } },
            { id: 'analyze', type: 'action.run_agent', label: 'Analyze Gaps', config: { prompt: 'Find missing tasks' }, position: { x: 400, y: 310 } },
            { id: 'create', type: 'action.run_command', label: 'Create Tasks', config: { command: 'bosun task import --from-plan', timeoutMs: 60000 }, position: { x: 400, y: 440 } },
            { id: 'prioritize', type: 'action.run_agent', label: 'Prioritize', config: { prompt: 'Prioritize the newly created tasks by impact and effort. Assign priorities 1-10.', sdk: 'auto' }, position: { x: 400, y: 570 } },
            { id: 'notify', type: 'notify.telegram', label: 'Notify', config: { message: ':clipboard: Backlog replenished with new tasks' }, position: { x: 400, y: 700 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'scan' }, { id: 'e2', source: 'scan', target: 'analyze' },
            { id: 'e3', source: 'analyze', target: 'create' }, { id: 'e4', source: 'create', target: 'prioritize' },
            { id: 'e5', source: 'prioritize', target: 'notify' },
          ],
        },
        {
          id: 'template-build-deploy', name: 'Build & Deploy', description: 'CI/CD pipeline: build → test → lint → deploy.', category: 'ci-cd', categoryLabel: 'CI / CD', categoryIcon: ':refresh:', categoryOrder: 4, tags: ['ci', 'cd', 'deploy'], nodeCount: 6, edgeCount: 5,
          nodes: [
            { id: 'trigger', type: 'trigger.event', label: 'PR Merged', config: { eventType: 'pr.merged' }, position: { x: 400, y: 50 } },
            { id: 'build', type: 'validation.build', label: 'Build', config: { command: 'npm run build' }, position: { x: 400, y: 180 } },
            { id: 'test', type: 'validation.tests', label: 'Tests', config: { command: 'npm test' }, position: { x: 400, y: 310 } },
            { id: 'lint', type: 'validation.lint', label: 'Lint', config: { command: 'npm run lint' }, position: { x: 400, y: 440 } },
            { id: 'deploy', type: 'action.run_command', label: 'Deploy', config: { command: 'npm run deploy' }, position: { x: 400, y: 570 } },
            { id: 'notify', type: 'notify.telegram', label: 'Notify', config: { message: ':rocket: Deployed' }, position: { x: 400, y: 700 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'build' }, { id: 'e2', source: 'build', target: 'test' },
            { id: 'e3', source: 'test', target: 'lint' }, { id: 'e4', source: 'lint', target: 'deploy' },
            { id: 'e5', source: 'deploy', target: 'notify' },
          ],
        },
        {
          id: 'template-error-recovery', name: 'Error Recovery', description: 'Auto-fix after agent crash or failure.', category: 'reliability', categoryLabel: 'Reliability', categoryIcon: ':shield:', categoryOrder: 5, tags: ['error', 'recovery', 'autofix'], nodeCount: 5, edgeCount: 4, recommended: true,
          nodes: [
            { id: 'trigger', type: 'trigger.event', label: 'Agent Failed', config: { eventType: 'task.failed' }, position: { x: 400, y: 50 } },
            { id: 'check-retries', type: 'condition.expression', label: 'Retries Left?', config: { expression: '($data?.retryCount || 0) < 3', trueLabel: 'retries > 0', falseLabel: 'exhausted' }, position: { x: 400, y: 180 } },
            { id: 'analyze-error', type: 'action.run_agent', label: 'Analyze Failure', config: { prompt: 'Analyze the failure: {{lastError}}\nDetermine root cause and suggest a targeted fix.', sdk: 'auto' }, position: { x: 200, y: 330 } },
            { id: 'retry-task', type: 'action.run_agent', label: 'Retry Task', config: { prompt: 'Retry the failed task. Previous error: {{lastError}}\nApply the fix from analysis and complete the task.', sdk: 'auto' }, position: { x: 200, y: 480 } },
            { id: 'escalate', type: 'notify.telegram', label: 'Escalate', config: { message: ':alert: Agent failed after max retries — manual intervention needed. Task: {{taskTitle}}' }, position: { x: 600, y: 180 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'check-retries' },
            { id: 'e2', source: 'check-retries', target: 'analyze-error', condition: 'retries > 0' },
            { id: 'e3', source: 'check-retries', target: 'escalate', condition: 'retries == 0' },
            { id: 'e4', source: 'analyze-error', target: 'retry-task' },
          ],
        },
        {
          id: 'template-custom-agent', name: 'Custom Agent', description: 'Starter template for creating custom agent profiles.', category: 'agents', categoryLabel: 'Agents', categoryIcon: ':bot:', categoryOrder: 2, tags: ['custom', 'agent', 'starter'], nodeCount: 6, edgeCount: 6,
          nodes: [
            { id: 'trigger', type: 'trigger.manual', label: 'Start', config: { inputFields: 'taskId,prompt' }, position: { x: 400, y: 50 } },
            { id: 'set-context', type: 'action.run_command', label: 'Set Context', config: { command: 'git status --porcelain && bosun task get {{taskId}} --json', timeoutMs: 30000 }, position: { x: 400, y: 180 } },
            { id: 'run-agent', type: 'action.run_agent', label: 'Run Agent', config: { prompt: 'Task: {{taskTitle}}' }, position: { x: 400, y: 310 } },
            { id: 'verify', type: 'validation.tests', label: 'Verify', config: { command: 'npm test' }, position: { x: 400, y: 440 } },
            { id: 'check-result', type: 'condition.expression', label: 'Passed?', config: { expression: '$data?.exitCode === 0', trueLabel: 'passed', falseLabel: 'failed' }, position: { x: 400, y: 570 } },
            { id: 'complete', type: 'action.update_task_status', label: 'Mark Done', config: { status: 'done' }, position: { x: 200, y: 700 } },
            { id: 'fail-notify', type: 'notify.log', label: 'Log Failure', config: { message: 'Agent task failed verification — needs review', level: 'error' }, position: { x: 600, y: 700 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'set-context' }, { id: 'e2', source: 'set-context', target: 'run-agent' },
            { id: 'e3', source: 'run-agent', target: 'verify' }, { id: 'e4', source: 'verify', target: 'check-result' },
            { id: 'e5', source: 'check-result', target: 'complete', condition: 'passed' },
            { id: 'e6', source: 'check-result', target: 'fail-notify', condition: 'failed' },
          ],
        },
        // ── New Templates ──────────────────────────────────────────
        {
          id: 'template-anomaly-watchdog', name: 'Anomaly Watchdog', description: 'Real-time anomaly detection — catches death loops, stalls, token overflows, rebase spirals.', category: 'reliability', categoryLabel: 'Reliability', categoryIcon: ':shield:', categoryOrder: 5, tags: ['anomaly', 'watchdog', 'death-loop', 'reliability'], nodeCount: 9, edgeCount: 12, recommended: true,
          nodes: [
            { id: 'trigger', type: 'trigger.event', label: 'Anomaly Detected', config: { eventType: 'agent.anomaly' }, position: { x: 400, y: 50 } },
            { id: 'classify', type: 'condition.switch', label: 'Classify Anomaly', config: { field: 'anomalyType' }, position: { x: 400, y: 200 } },
            { id: 'kill-and-restart', type: 'action.restart_agent', label: 'Kill & Restart', config: { reason: 'Death loop detected' }, position: { x: 100, y: 380 } },
            { id: 'nudge-stall', type: 'action.continue_session', label: 'Nudge Stalled', config: { strategy: 'continue' }, position: { x: 300, y: 380 } },
            { id: 'trim-context', type: 'action.continue_session', label: 'Trim Context', config: { strategy: 'refine' }, position: { x: 500, y: 380 } },
            { id: 'fix-rebase', type: 'action.run_command', label: 'Fix Rebase', config: { command: 'git rebase --abort' }, position: { x: 700, y: 380 } },
            { id: 'break-spin', type: 'action.continue_session', label: 'Break Spin', config: { strategy: 'continue' }, position: { x: 900, y: 380 } },
            { id: 'log-intervention', type: 'notify.log', label: 'Log Intervention', config: { level: 'warn' }, position: { x: 400, y: 550 } },
            { id: 'alert-telegram', type: 'notify.telegram', label: 'Alert Human', config: { message: ':alert: Agent anomaly auto-resolved' }, position: { x: 400, y: 700 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'classify' },
            { id: 'e2', source: 'classify', target: 'kill-and-restart', condition: 'death-loop' },
            { id: 'e3', source: 'classify', target: 'nudge-stall', condition: 'stall' },
            { id: 'e4', source: 'classify', target: 'trim-context', condition: 'token-overflow' },
            { id: 'e5', source: 'classify', target: 'fix-rebase', condition: 'rebase-spiral' },
            { id: 'e6', source: 'classify', target: 'break-spin', condition: 'thought-spin' },
            { id: 'e7', source: 'kill-and-restart', target: 'log-intervention' },
            { id: 'e8', source: 'nudge-stall', target: 'log-intervention' },
            { id: 'e9', source: 'trim-context', target: 'log-intervention' },
            { id: 'e10', source: 'fix-rebase', target: 'log-intervention' },
            { id: 'e11', source: 'break-spin', target: 'log-intervention' },
            { id: 'e12', source: 'log-intervention', target: 'alert-telegram' },
          ],
        },
        {
          id: 'template-workspace-hygiene', name: 'Workspace Hygiene', description: 'Scheduled maintenance: prune worktrees, kill stale processes, rotate logs.', category: 'reliability', categoryLabel: 'Reliability', categoryIcon: ':shield:', categoryOrder: 5, tags: ['maintenance', 'cleanup', 'worktree', 'hygiene'], nodeCount: 8, edgeCount: 9, recommended: true,
          nodes: [
            { id: 'trigger', type: 'trigger.schedule', label: 'Daily Cleanup', config: { cron: '0 3 * * *' }, position: { x: 400, y: 50 } },
            { id: 'prune-worktrees', type: 'action.run_command', label: 'Prune Worktrees', config: { command: 'git worktree prune' }, position: { x: 150, y: 200 } },
            { id: 'kill-stale', type: 'action.run_command', label: 'Kill Stale', config: { command: 'bosun maintenance --kill-stale' }, position: { x: 400, y: 200 } },
            { id: 'rotate-logs', type: 'action.run_command', label: 'Rotate Logs', config: { command: 'find .bosun/logs -mtime +7 -delete' }, position: { x: 650, y: 200 } },
            { id: 'clean-evidence', type: 'action.run_command', label: 'Clean Evidence', config: { command: 'find .bosun/evidence -mtime +14 -delete' }, position: { x: 150, y: 380 } },
            { id: 'check-disk', type: 'action.run_command', label: 'Check Disk', config: { command: 'du -sh .bosun/' }, position: { x: 400, y: 380 } },
            { id: 'gc-git', type: 'action.run_command', label: 'Git GC', config: { command: 'git gc --auto --quiet' }, position: { x: 650, y: 380 } },
            { id: 'summary', type: 'notify.log', label: 'Log Summary', config: { level: 'info' }, position: { x: 400, y: 540 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'prune-worktrees' }, { id: 'e2', source: 'trigger', target: 'kill-stale' },
            { id: 'e3', source: 'trigger', target: 'rotate-logs' }, { id: 'e4', source: 'prune-worktrees', target: 'clean-evidence' },
            { id: 'e5', source: 'kill-stale', target: 'check-disk' }, { id: 'e6', source: 'rotate-logs', target: 'gc-git' },
            { id: 'e7', source: 'clean-evidence', target: 'summary' }, { id: 'e8', source: 'check-disk', target: 'summary' },
            { id: 'e9', source: 'gc-git', target: 'summary' },
          ],
        },
        {
          id: 'template-pr-conflict-resolver', name: 'PR Conflict Resolver', description: 'Auto-detect conflicted PRs, rebase, fix conflicts, re-run CI, merge.', category: 'github', categoryLabel: 'GitHub', categoryIcon: ':git:', categoryOrder: 1, tags: ['github', 'pr', 'conflict', 'rebase'], nodeCount: 10, edgeCount: 9, recommended: true,
          nodes: [
            { id: 'trigger', type: 'trigger.schedule', label: 'Check Every 30min', config: { cron: '*/30 * * * *' }, position: { x: 400, y: 50 } },
            { id: 'list-prs', type: 'action.run_command', label: 'List Open PRs', config: { command: 'gh pr list --json number,mergeable --limit 20' }, position: { x: 400, y: 180 } },
            { id: 'has-conflicts', type: 'condition.expression', label: 'Any Conflicts?', config: { expression: 'output.includes("CONFLICTING")' }, position: { x: 400, y: 330 } },
            { id: 'resolve-conflicts', type: 'action.run_agent', label: 'Resolve Conflicts', config: { prompt: 'Rebase each conflicted PR onto main and resolve conflicts.' }, position: { x: 200, y: 500 } },
            { id: 'verify-ci', type: 'action.run_command', label: 'Verify CI', config: { command: 'gh pr checks' }, position: { x: 200, y: 660 } },
            { id: 'auto-merge', type: 'condition.expression', label: 'CI Passed?', config: { expression: 'success === true' }, position: { x: 200, y: 810 } },
            { id: 'do-merge', type: 'action.run_command', label: 'Auto-Merge', config: { command: 'gh pr merge --auto --squash' }, position: { x: 100, y: 960 } },
            { id: 'notify-fixed', type: 'notify.telegram', label: 'Notify Fixed', config: { message: ':settings: PR conflicts resolved and merged' }, position: { x: 100, y: 1100 } },
            { id: 'notify-failed', type: 'notify.log', label: 'CI Failed', config: { level: 'warn' }, position: { x: 400, y: 960 } },
            { id: 'skip', type: 'notify.log', label: 'No Conflicts', config: { level: 'info' }, position: { x: 600, y: 500 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'list-prs' }, { id: 'e2', source: 'list-prs', target: 'has-conflicts' },
            { id: 'e3', source: 'has-conflicts', target: 'resolve-conflicts', condition: 'conflicts' },
            { id: 'e4', source: 'has-conflicts', target: 'skip', condition: 'clean' },
            { id: 'e5', source: 'resolve-conflicts', target: 'verify-ci' }, { id: 'e6', source: 'verify-ci', target: 'auto-merge' },
            { id: 'e7', source: 'auto-merge', target: 'do-merge', condition: 'passed' },
            { id: 'e8', source: 'auto-merge', target: 'notify-failed', condition: 'failed' },
            { id: 'e9', source: 'do-merge', target: 'notify-fixed' },
          ],
        },
        {
          id: 'template-health-check', name: 'Health Check', description: 'Periodic system health check: config, git state, agent status.', category: 'reliability', categoryLabel: 'Reliability', categoryIcon: ':shield:', categoryOrder: 5, tags: ['health', 'config', 'doctor', 'monitoring'], nodeCount: 7, edgeCount: 8,
          nodes: [
            { id: 'trigger', type: 'trigger.schedule', label: 'Hourly Check', config: { cron: '0 * * * *' }, position: { x: 400, y: 50 } },
            { id: 'check-config', type: 'action.bosun_cli', label: 'Check Config', config: { subcommand: 'doctor' }, position: { x: 150, y: 200 } },
            { id: 'check-git', type: 'action.run_command', label: 'Check Git', config: { command: 'git status --porcelain' }, position: { x: 400, y: 200 } },
            { id: 'check-agents', type: 'action.run_command', label: 'Check Agents', config: { command: 'bosun --daemon-status' }, position: { x: 650, y: 200 } },
            { id: 'has-issues', type: 'condition.expression', label: 'Issues Found?', config: { expression: 'output.includes("ERROR")' }, position: { x: 400, y: 380 } },
            { id: 'alert', type: 'notify.telegram', label: 'Alert Issues', config: { message: ':heart: Health check found issues' }, position: { x: 200, y: 540 } },
            { id: 'all-ok', type: 'notify.log', label: 'All Healthy', config: { level: 'info' }, position: { x: 600, y: 540 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'check-config' }, { id: 'e2', source: 'trigger', target: 'check-git' },
            { id: 'e3', source: 'trigger', target: 'check-agents' }, { id: 'e4', source: 'check-config', target: 'has-issues' },
            { id: 'e5', source: 'check-git', target: 'has-issues' }, { id: 'e6', source: 'check-agents', target: 'has-issues' },
            { id: 'e7', source: 'has-issues', target: 'alert', condition: 'issues' },
            { id: 'e8', source: 'has-issues', target: 'all-ok', condition: 'healthy' },
          ],
        },
        {
          id: 'template-stale-pr-reaper', name: 'Stale PR Reaper', description: 'Close stale PRs inactive for too long, clean up branches.', category: 'github', categoryLabel: 'GitHub', categoryIcon: ':git:', categoryOrder: 1, tags: ['github', 'pr', 'stale', 'cleanup'], nodeCount: 8, edgeCount: 7,
          nodes: [
            { id: 'trigger', type: 'trigger.schedule', label: 'Daily Check', config: { cron: '0 8 * * *' }, position: { x: 400, y: 50 } },
            { id: 'find-stale', type: 'action.run_command', label: 'Find Stale PRs', config: { command: 'gh pr list --json number,updatedAt --limit 50' }, position: { x: 400, y: 200 } },
            { id: 'has-stale', type: 'condition.expression', label: 'Any Stale?', config: { expression: 'output.length > 2' }, position: { x: 400, y: 350 } },
            { id: 'warn-stale', type: 'action.run_command', label: 'Post Warning', config: { command: 'echo "Would warn stale PRs"' }, position: { x: 200, y: 500 } },
            { id: 'close-stale', type: 'action.run_command', label: 'Close Expired', config: { command: 'echo "Would close stale PRs"' }, position: { x: 200, y: 650 } },
            { id: 'cleanup-branches', type: 'action.run_command', label: 'Prune Branches', config: { command: 'git fetch --prune origin' }, position: { x: 200, y: 800 } },
            { id: 'summary', type: 'notify.telegram', label: 'Summary', config: { message: ':trash: Stale PR cleanup complete' }, position: { x: 200, y: 950 } },
            { id: 'skip', type: 'notify.log', label: 'No Stale PRs', config: { level: 'info' }, position: { x: 600, y: 500 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'find-stale' }, { id: 'e2', source: 'find-stale', target: 'has-stale' },
            { id: 'e3', source: 'has-stale', target: 'warn-stale', condition: 'stale' },
            { id: 'e4', source: 'has-stale', target: 'skip', condition: 'clean' },
            { id: 'e5', source: 'warn-stale', target: 'close-stale' }, { id: 'e6', source: 'close-stale', target: 'cleanup-branches' },
            { id: 'e7', source: 'cleanup-branches', target: 'summary' },
          ],
        },
        {
          id: 'template-agent-session-monitor', name: 'Agent Session Monitor', description: 'Monitors active sessions for timeouts, inactivity, auto-continues stalled agents.', category: 'agents', categoryLabel: 'Agents', categoryIcon: ':bot:', categoryOrder: 2, tags: ['agent', 'monitor', 'session', 'health'], nodeCount: 9, edgeCount: 8, recommended: true,
          nodes: [
            { id: 'trigger', type: 'trigger.schedule', label: 'Check Every 5min', config: { cron: '*/5 * * * *' }, position: { x: 400, y: 50 } },
            { id: 'list-sessions', type: 'action.run_command', label: 'List Sessions', config: { command: 'bosun agent list --json --active' }, position: { x: 400, y: 200 } },
            { id: 'has-active', type: 'condition.expression', label: 'Any Active?', config: { expression: 'output.length > 5' }, position: { x: 400, y: 340 } },
            { id: 'check-health', type: 'action.run_command', label: 'Check Health', config: { command: 'bosun agent health --json' }, position: { x: 200, y: 490 } },
            { id: 'has-issues', type: 'condition.expression', label: 'Any Unhealthy?', config: { expression: 'output.includes("stalled")' }, position: { x: 200, y: 640 } },
            { id: 'auto-continue', type: 'action.continue_session', label: 'Auto-Continue', config: { strategy: 'continue' }, position: { x: 100, y: 800 } },
            { id: 'alert-hung', type: 'notify.telegram', label: 'Alert Hung', config: { message: ':dot: Agent session hung — auto-continue attempted' }, position: { x: 100, y: 950 } },
            { id: 'all-healthy', type: 'notify.log', label: 'All Healthy', config: { level: 'info' }, position: { x: 450, y: 640 } },
            { id: 'no-sessions', type: 'notify.log', label: 'No Sessions', config: { level: 'info' }, position: { x: 600, y: 490 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'list-sessions' }, { id: 'e2', source: 'list-sessions', target: 'has-active' },
            { id: 'e3', source: 'has-active', target: 'check-health', condition: 'active' },
            { id: 'e4', source: 'has-active', target: 'no-sessions', condition: 'none' },
            { id: 'e5', source: 'check-health', target: 'has-issues' },
            { id: 'e6', source: 'has-issues', target: 'auto-continue', condition: 'unhealthy' },
            { id: 'e7', source: 'has-issues', target: 'all-healthy', condition: 'healthy' },
            { id: 'e8', source: 'auto-continue', target: 'alert-hung' },
          ],
        },
        {
          id: 'template-nightly-report', name: 'Nightly Report', description: 'Daily summary: tasks completed, PRs merged, errors, token usage.', category: 'planning', categoryLabel: 'Planning', categoryIcon: ':clipboard:', categoryOrder: 3, tags: ['report', 'daily', 'telegram', 'analytics'], nodeCount: 6, edgeCount: 7,
          nodes: [
            { id: 'trigger', type: 'trigger.schedule', label: 'Nightly 11pm', config: { cron: '0 23 * * *' }, position: { x: 400, y: 50 } },
            { id: 'get-task-stats', type: 'action.run_command', label: 'Task Stats', config: { command: 'bosun task stats --json' }, position: { x: 150, y: 200 } },
            { id: 'get-pr-stats', type: 'action.run_command', label: 'PR Stats', config: { command: 'gh pr list --state all --json number,state --limit 50' }, position: { x: 400, y: 200 } },
            { id: 'get-agent-stats', type: 'action.run_command', label: 'Agent Stats', config: { command: 'bosun agent stats --json' }, position: { x: 650, y: 200 } },
            { id: 'generate-report', type: 'action.run_agent', label: 'Generate Report', config: { prompt: 'Generate daily activity summary' }, position: { x: 400, y: 380 } },
            { id: 'send-report', type: 'notify.telegram', label: 'Send Report', config: { message: ':chart: Daily Bosun Report' }, position: { x: 400, y: 540 } },
          ],
          edges: [
            { id: 'e1', source: 'trigger', target: 'get-task-stats' }, { id: 'e2', source: 'trigger', target: 'get-pr-stats' },
            { id: 'e3', source: 'trigger', target: 'get-agent-stats' }, { id: 'e4', source: 'get-task-stats', target: 'generate-report' },
            { id: 'e5', source: 'get-pr-stats', target: 'generate-report' }, { id: 'e6', source: 'get-agent-stats', target: 'generate-report' },
            { id: 'e7', source: 'generate-report', target: 'send-report' },
          ],
        },
      ],
      workflowNodeTypes: [
        // ── TRIGGERS ─────────────────────────────────────────────────
        { type: 'trigger.task_assigned', category: 'trigger', description: 'Fires when a task is assigned to an agent',
          schema: { type: 'object', properties: {
            taskFilter: { type: 'string', description: 'Filter tasks by tag or status pattern' },
            agentFilter: { type: 'string', description: 'Only fire for specific agent SDKs' },
          }}},
        { type: 'trigger.pr_event', category: 'trigger', description: 'Fires on PR open/update/merge events',
          schema: { type: 'object', properties: {
            events: { type: 'string', description: 'Comma-separated: opened,synchronize,closed,merged,review_submitted' },
            branchFilter: { type: 'string', description: 'Branch glob pattern (e.g., feature/*)' },
          }}},
        { type: 'trigger.cron', category: 'trigger', description: 'Fires on a cron schedule',
          schema: { type: 'object', properties: {
            schedule: { type: 'string', description: 'Cron expression (e.g., */5 * * * *)' },
            timezone: { type: 'string', default: 'UTC', description: 'IANA timezone' },
          }}},
        { type: 'trigger.event', category: 'trigger', description: 'Fires on a named event',
          schema: { type: 'object', properties: {
            eventName: { type: 'string', description: 'Event name (e.g., task.failed, agent.crashed, rate.limited)' },
            filter: { type: 'string', description: 'JS expression to filter events' },
          }}},
        { type: 'trigger.webhook', category: 'trigger', description: 'Fires on incoming webhook',
          schema: { type: 'object', properties: {
            path: { type: 'string', default: '/webhook', description: 'Webhook endpoint path' },
            secret: { type: 'string', description: 'HMAC secret for verification' },
          }}},
        { type: 'trigger.file_change', category: 'trigger', description: 'Fires when files change',
          schema: { type: 'object', properties: {
            glob: { type: 'string', description: 'File glob pattern (e.g., src/**/*.ts)' },
            debounceMs: { type: 'number', default: 1000, description: 'Debounce time in ms' },
          }}},
        { type: 'trigger.manual', category: 'trigger', description: 'Manual trigger',
          schema: { type: 'object', properties: {
            inputFields: { type: 'string', description: 'Comma-separated input field names for manual trigger form' },
          }}},

        // ── CONDITIONS ───────────────────────────────────────────────
        { type: 'condition.expression', category: 'condition', description: 'Evaluate a JS expression',
          schema: { type: 'object', properties: {
            expression: { type: 'string', description: 'JS expression (e.g., ctx.data.exitCode === 0)' },
            trueLabel: { type: 'string', default: 'yes', description: 'Label for true branch' },
            falseLabel: { type: 'string', default: 'no', description: 'Label for false branch' },
          }}},
        { type: 'condition.switch', category: 'condition', description: 'Multi-branch switch on a field',
          schema: { type: 'object', properties: {
            field: { type: 'string', description: 'Data field to switch on (e.g., ctx.data.decision)' },
            cases: { type: 'string', description: 'Comma-separated case values (merge,re_attempt,close,wait)' },
          }}},
        { type: 'condition.file_exists', category: 'condition', description: 'Check if a file/path exists',
          schema: { type: 'object', properties: {
            path: { type: 'string', description: 'File path to check (supports {{variables}})' },
          }}},
        { type: 'condition.approval', category: 'condition', description: 'Wait for human approval',
          schema: { type: 'object', properties: {
            message: { type: 'string', description: 'Message to show for approval' },
            channel: { type: 'string', enum: ['telegram', 'ui', 'both'], default: 'both' },
            timeoutMs: { type: 'number', default: 3600000, description: 'Approval timeout (ms)' },
          }}},

        // ── ACTIONS ──────────────────────────────────────────────────
        { type: 'action.run_agent', category: 'action', description: 'Execute an AI agent with a prompt',
          schema: { type: 'object', properties: {
            prompt: { type: 'string', description: 'Agent prompt (supports {{taskTitle}}, {{lastError}}, etc.)' },
            sdk: { type: 'string', enum: ['codex', 'copilot', 'claude', 'auto'], default: 'auto' },
            cwd: { type: 'string', description: 'Working directory' },
            timeoutMs: { type: 'number', default: 3600000, description: 'Agent timeout (ms)' },
            model: { type: 'string', description: 'Model override' },
          }}},
        { type: 'action.run_command', category: 'action', description: 'Run a shell command',
          schema: { type: 'object', properties: {
            command: { type: 'string', description: 'Shell command to execute' },
            cwd: { type: 'string', description: 'Working directory' },
            timeoutMs: { type: 'number', default: 120000, description: 'Command timeout (ms)' },
            shell: { type: 'boolean', default: true, description: 'Use shell' },
          }}},
        { type: 'action.git_commit', category: 'action', description: 'Stage and commit changes',
          schema: { type: 'object', properties: {
            message: { type: 'string', description: 'Commit message (conventional commits)' },
            branch: { type: 'string', description: 'Branch name' },
            addAll: { type: 'boolean', default: true, description: 'Stage all changes' },
            push: { type: 'boolean', default: true, description: 'Push after commit' },
          }}},
        { type: 'action.create_pr', category: 'action', description: 'Record Bosun PR lifecycle handoff',
          schema: { type: 'object', properties: {
            title: { type: 'string', description: 'PR title' },
            body: { type: 'string', description: 'Lifecycle handoff summary / description' },
            base: { type: 'string', default: 'main', description: 'Base branch' },
            draft: { type: 'boolean', default: false, description: 'Retained for compatibility' },
          }}},
        { type: 'action.update_task_status', category: 'action', description: 'Update task status',
          schema: { type: 'object', properties: {
            status: { type: 'string', enum: ['todo', 'in_progress', 'in_review', 'done', 'blocked', 'failed'], description: 'New status' },
            taskId: { type: 'string', description: 'Task ID (auto-detected from workflow context if empty)' },
          }}},
        { type: 'action.delay', category: 'action', description: 'Wait for a duration',
          schema: { type: 'object', properties: {
            durationMs: { type: 'number', default: 5000, description: 'Delay in milliseconds' },
            reason: { type: 'string', description: 'Reason for delay (for logging)' },
          }}},
        { type: 'action.http_request', category: 'action', description: 'Make an HTTP request',
          schema: { type: 'object', properties: {
            url: { type: 'string', description: 'Request URL' },
            method: { type: 'string', enum: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'], default: 'GET' },
            headers: { type: 'string', description: 'JSON headers object' },
            body: { type: 'string', description: 'Request body' },
          }}},
        { type: 'action.file_write', category: 'action', description: 'Write content to a file',
          schema: { type: 'object', properties: {
            path: { type: 'string', description: 'File path' },
            content: { type: 'string', description: 'File content to write' },
            append: { type: 'boolean', default: false, description: 'Append instead of overwrite' },
          }}},
        { type: 'action.assign_agent', category: 'action', description: 'Assign an agent to a task',
          schema: { type: 'object', properties: {
            taskId: { type: 'string', description: 'Task ID' },
            sdk: { type: 'string', enum: ['codex', 'copilot', 'claude', 'auto'], default: 'auto' },
            priority: { type: 'number', default: 5, description: 'Agent priority (1-10)' },
          }}},
        { type: 'action.merge_pr', category: 'action', description: 'Merge a pull request',
          schema: { type: 'object', properties: {
            prNumber: { type: 'number', description: 'PR number (auto-detected if empty)' },
            method: { type: 'string', enum: ['squash', 'merge', 'rebase'], default: 'squash' },
            deleteAfterMerge: { type: 'boolean', default: true, description: 'Delete branch after merge' },
          }}},

        // ── NEW: SESSION & AGENT MANAGEMENT ──────────────────────────
        { type: 'action.continue_session', category: 'action', description: 'Re-attach to an existing agent session and prompt it to continue',
          schema: { type: 'object', properties: {
            prompt: { type: 'string', description: 'Continuation prompt for the agent' },
            sessionId: { type: 'string', description: 'Session ID to continue (auto-detected if empty)' },
            strategy: { type: 'string', enum: ['continue', 'retry', 'refine', 'finish_up'], default: 'continue' },
            timeoutMs: { type: 'number', default: 1800000, description: 'Timeout (ms)' },
          }}},
        { type: 'action.restart_agent', category: 'action', description: 'Kill and restart an agent session from scratch',
          schema: { type: 'object', properties: {
            prompt: { type: 'string', description: 'New prompt for the restarted agent' },
            reason: { type: 'string', description: 'Reason for restart (logged and given as context)' },
            sdk: { type: 'string', enum: ['codex', 'copilot', 'claude', 'auto'], default: 'auto' },
            sessionId: { type: 'string', description: 'Session to kill first' },
          }}},
        { type: 'action.bosun_cli', category: 'action', description: 'Run a bosun CLI command',
          schema: { type: 'object', properties: {
            subcommand: { type: 'string', description: 'Bosun subcommand (e.g., task list, agent continue, --daemon-status)' },
            args: { type: 'string', description: 'Additional arguments' },
            parseJson: { type: 'boolean', default: true, description: 'Auto-parse JSON output' },
          }}},
        { type: 'action.handle_rate_limit', category: 'action', description: 'Handle rate limits with backoff & provider rotation',
          schema: { type: 'object', properties: {
            strategy: { type: 'string', enum: ['wait', 'rotate', 'skip'], default: 'wait', description: 'Rate limit strategy' },
            baseDelayMs: { type: 'number', default: 60000, description: 'Base delay before retry (ms)' },
            maxRetries: { type: 'number', default: 5, description: 'Maximum retry attempts' },
            fallbackProvider: { type: 'string', enum: ['codex', 'copilot', 'claude', 'none'], default: 'none' },
          }}},
        { type: 'action.ask_user', category: 'action', description: 'Pause workflow and ask user for input',
          schema: { type: 'object', properties: {
            question: { type: 'string', description: 'Question to ask the user' },
            options: { type: 'string', description: 'Comma-separated quick-reply options' },
            channel: { type: 'string', enum: ['telegram', 'ui', 'both'], default: 'both' },
            timeoutMs: { type: 'number', default: 3600000 },
            variable: { type: 'string', default: 'userResponse', description: 'Variable to store response' },
          }}},
        { type: 'action.analyze_errors', category: 'action', description: 'Run error detector on recent logs',
          schema: { type: 'object', properties: {
            logSource: { type: 'string', enum: ['agent', 'build', 'test', 'all'], default: 'all' },
            timeWindowMs: { type: 'number', default: 3600000, description: 'How far back to look (ms)' },
            minSeverity: { type: 'string', enum: ['info', 'warn', 'error', 'fatal'], default: 'error' },
            outputVariable: { type: 'string', default: 'errorAnalysis' },
          }}},
        { type: 'action.refresh_worktree', category: 'action', description: 'Refresh git worktree state',
          schema: { type: 'object', properties: {
            operation: { type: 'string', enum: ['fetch', 'pull', 'reset_hard', 'clean', 'checkout_main'], default: 'fetch' },
            branch: { type: 'string', default: 'main', description: 'Branch to operate on' },
          }}},

        // ── VALIDATION ───────────────────────────────────────────────
        { type: 'validation.build', category: 'validation', description: 'Run build and check exit code',
          schema: { type: 'object', properties: {
            command: { type: 'string', default: 'npm run build', description: 'Build command' },
            cwd: { type: 'string', description: 'Working directory' },
            failOnWarning: { type: 'boolean', default: false, description: 'Treat warnings as failures' },
          }}},
        { type: 'validation.tests', category: 'validation', description: 'Run test suite',
          schema: { type: 'object', properties: {
            command: { type: 'string', default: 'npm test', description: 'Test command' },
            cwd: { type: 'string', description: 'Working directory' },
            minCoverage: { type: 'number', description: 'Minimum coverage % to pass' },
          }}},
        { type: 'validation.lint', category: 'validation', description: 'Run linter',
          schema: { type: 'object', properties: {
            command: { type: 'string', default: 'npm run lint', description: 'Lint command' },
            autoFix: { type: 'boolean', default: false, description: 'Auto-fix issues' },
          }}},
        { type: 'validation.type_check', category: 'validation', description: 'Run type checker',
          schema: { type: 'object', properties: {
            command: { type: 'string', default: 'npx tsc --noEmit', description: 'Type check command' },
          }}},
        { type: 'validation.security_scan', category: 'validation', description: 'Run security scanner',
          schema: { type: 'object', properties: {
            command: { type: 'string', default: 'npm audit --json', description: 'Security scan command' },
            failOnHigh: { type: 'boolean', default: true, description: 'Fail on high severity' },
          }}},

        // ── TRANSFORM ────────────────────────────────────────────────
        { type: 'transform.map', category: 'transform', description: 'Transform data with a function',
          schema: { type: 'object', properties: {
            expression: { type: 'string', description: 'JS mapping expression (e.g., item => item.name)' },
            inputField: { type: 'string', default: 'items', description: 'Input data field' },
            outputField: { type: 'string', default: 'result', description: 'Output data field' },
          }}},
        { type: 'transform.filter', category: 'transform', description: 'Filter data by condition',
          schema: { type: 'object', properties: {
            expression: { type: 'string', description: 'JS filter expression (e.g., item => item.status !== "done")' },
            inputField: { type: 'string', default: 'items' },
            outputField: { type: 'string', default: 'filtered' },
          }}},
        { type: 'transform.aggregate', category: 'transform', description: 'Aggregate outputs from multiple nodes',
          schema: { type: 'object', properties: {
            sourceNodes: { type: 'string', description: 'Comma-separated node IDs to aggregate from' },
            outputField: { type: 'string', default: 'aggregated' },
          }}},

        // ── NOTIFY ───────────────────────────────────────────────────
        { type: 'notify.telegram', category: 'notify', description: 'Send Telegram notification',
          schema: { type: 'object', properties: {
            message: { type: 'string', description: 'Message text (supports {{variables}} and Markdown)' },
            chatId: { type: 'string', description: 'Chat ID (uses default if empty)' },
            parseMode: { type: 'string', enum: ['Markdown', 'HTML', 'plain'], default: 'Markdown' },
          }}},
        { type: 'notify.log', category: 'notify', description: 'Write to agent log',
          schema: { type: 'object', properties: {
            message: { type: 'string', description: 'Log message' },
            level: { type: 'string', enum: ['debug', 'info', 'warn', 'error'], default: 'info' },
          }}},
        { type: 'notify.webhook', category: 'notify', description: 'POST to a webhook URL',
          schema: { type: 'object', properties: {
            url: { type: 'string', description: 'Webhook URL' },
            payload: { type: 'string', description: 'JSON payload (supports {{variables}})' },
          }}},

        // ── AGENT ────────────────────────────────────────────────────
        { type: 'agent.spawn', category: 'agent', description: 'Spawn a new agent instance',
          schema: { type: 'object', properties: {
            prompt: { type: 'string', description: 'Agent prompt' },
            sdk: { type: 'string', enum: ['codex', 'copilot', 'claude', 'auto'], default: 'auto' },
            cwd: { type: 'string', description: 'Working directory' },
            timeoutMs: { type: 'number', default: 3600000 },
          }}},
        { type: 'agent.pool_exec', category: 'agent', description: 'Execute via agent pool',
          schema: { type: 'object', properties: {
            prompt: { type: 'string', description: 'Task prompt for the pool' },
            priority: { type: 'number', default: 5 },
            maxConcurrent: { type: 'number', default: 1, description: 'Max concurrent agents' },
          }}},
        { type: 'agent.review', category: 'agent', description: 'Run review agent',
          schema: { type: 'object', properties: {
            prNumber: { type: 'number', description: 'PR number to review' },
            criteria: { type: 'string', description: 'Review criteria (quality,bugs,tests,docs)' },
            autoApprove: { type: 'boolean', default: false },
          }}},

        // ── LOOP ─────────────────────────────────────────────────────
        { type: 'loop.for_each', category: 'loop', description: 'Iterate over a list',
          schema: { type: 'object', properties: {
            items: { type: 'string', description: 'Data field containing items list' },
            itemVariable: { type: 'string', default: 'item', description: 'Loop variable name' },
            maxIterations: { type: 'number', default: 100 },
          }}},
      ],
      workflowRuns: [
        { runId: 'run-001', workflowId: 'wf-pr-merge-auto', status: 'completed', nodeCount: 14, duration: 42000, errorCount: 0, startedAt: new Date(now - 2 * hr).toISOString() },
        { runId: 'run-002', workflowId: 'wf-pr-merge-auto', status: 'completed', nodeCount: 14, duration: 38000, errorCount: 0, startedAt: new Date(now - 6 * hr).toISOString() },
        { runId: 'run-003', workflowId: 'wf-error-recovery', status: 'failed', nodeCount: 3, duration: 15000, errorCount: 1, startedAt: new Date(now - 12 * hr).toISOString() },
        { runId: 'run-004', workflowId: 'wf-pr-merge-auto', status: 'completed', nodeCount: 14, duration: 55000, errorCount: 0, startedAt: new Date(now - 24 * hr).toISOString() },
        { runId: 'run-005', workflowId: 'wf-review-agent', status: 'completed', nodeCount: 6, duration: 28000, errorCount: 0, startedAt: new Date(now - 4 * hr).toISOString() },
        { runId: 'run-006', workflowId: 'wf-build-deploy', status: 'completed', nodeCount: 6, duration: 92000, errorCount: 0, startedAt: new Date(now - 8 * hr).toISOString() },
        { runId: 'run-007', workflowId: 'wf-task-planner', status: 'completed', nodeCount: 5, duration: 35000, errorCount: 0, startedAt: new Date(now - 3 * hr).toISOString() },
        { runId: 'run-008', workflowId: 'wf-frontend-agent', status: 'completed', nodeCount: 8, duration: 180000, errorCount: 0, startedAt: new Date(now - 1 * hr).toISOString() },
      ],
    };

    /* ── Helper: find task by ID ───────────────────────────────────── */
    function findTask(id) { return STATE.tasks.find(t => t.id === id); }
    function addLog(level, source, msg) {
      STATE.logs.unshift({ ts: Date.now(), level, source, msg });
      if (STATE.logs.length > 100) STATE.logs.length = 100;
    }
    function slugify(name) {
      return String(name || "")
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-|-$/g, "");
    }
    function ensureLibrarySeeded(force = false) {
      if (!force && STATE.libraryEntries.length) {
        return { entries: STATE.libraryEntries.length, scaffolded: 0 };
      }
      const created = new Date(now - 6 * hr).toISOString();
      const updated = new Date(now - 2 * hr).toISOString();
      const entries = [
        {
          id: "task-executor",
          type: "prompt",
          name: "Task Executor",
          description: "Default task execution prompt for autonomous agents.",
          filename: "task-executor.md",
          tags: ["executor", "task", "agent"],
          scope: "global",
          workspace: null,
          createdAt: created,
          updatedAt: updated,
        },
        {
          id: "reviewer",
          type: "prompt",
          name: "PR Reviewer",
          description: "Review prompt for quality, tests, and regressions.",
          filename: "reviewer.md",
          tags: ["review", "quality", "pr"],
          scope: "global",
          workspace: null,
          createdAt: created,
          updatedAt: updated,
        },
        {
          id: "frontend-agent",
          type: "agent",
          name: "Frontend Agent",
          description: "UI-focused agent profile with screenshot validation.",
          filename: "frontend-agent.json",
          tags: ["frontend", "ui", "css", "screenshot"],
          scope: "global",
          workspace: null,
          createdAt: created,
          updatedAt: updated,
        },
        {
          id: "backend-agent",
          type: "agent",
          name: "Backend Agent",
          description: "API-first agent profile for services and data.",
          filename: "backend-agent.json",
          tags: ["backend", "api", "db"],
          scope: "global",
          workspace: null,
          createdAt: created,
          updatedAt: updated,
        },
        {
          id: "testing-agent",
          type: "agent",
          name: "Testing Agent",
          description: "Test/QA agent profile for coverage and CI validation.",
          filename: "testing-agent.json",
          tags: ["tests", "qa", "ci"],
          scope: "global",
          workspace: null,
          createdAt: created,
          updatedAt: updated,
        },
        {
          id: "lint-sheriff",
          type: "skill",
          name: "Lint Sheriff",
          description: "Skill: fix lint errors quickly and safely.",
          filename: "lint-sheriff.md",
          tags: ["lint", "eslint", "format"],
          scope: "global",
          workspace: null,
          createdAt: created,
          updatedAt: updated,
        },
        {
          id: "docs-polish",
          type: "skill",
          name: "Docs Polish",
          description: "Skill: update docs, changelogs, and READMEs.",
          filename: "docs-polish.md",
          tags: ["docs", "readme"],
          scope: "global",
          workspace: null,
          createdAt: created,
          updatedAt: updated,
        },
      ];
      const contents = {
        "task-executor": "# Task Executor\n\nFocus on delivering a clean implementation with tests and clear output.\n",
        reviewer: "# PR Reviewer\n\nCheck for regressions, missing tests, and risky changes.\n",
        "frontend-agent": {
          id: "frontend-agent",
          name: "Frontend Agent",
          description: "UI-focused agent profile with screenshot validation.",
          titlePatterns: ["ui", "frontend", "css", "layout", "design"],
          scopes: ["ui", "frontend", "portal", "web", "css"],
          sdk: "COPILOT",
          model: null,
          promptOverride: null,
          skills: ["lint-sheriff", "docs-polish"],
          env: { UI_SCREENSHOT_REQUIRED: "1" },
        },
        "backend-agent": {
          id: "backend-agent",
          name: "Backend Agent",
          description: "API-first agent profile for services and data.",
          titlePatterns: ["api", "backend", "db", "server"],
          scopes: ["api", "server", "db", "backend"],
          sdk: "CODEX",
          model: null,
          promptOverride: null,
          skills: ["lint-sheriff"],
          env: {},
        },
        "testing-agent": {
          id: "testing-agent",
          name: "Testing Agent",
          description: "Test/QA agent profile for coverage and CI validation.",
          titlePatterns: ["test", "qa", "coverage", "ci"],
          scopes: ["test", "tests", "ci"],
          sdk: "CODEX",
          model: null,
          promptOverride: null,
          skills: [],
          env: {},
        },
        "lint-sheriff": "# Lint Sheriff\n\n## Purpose\nFix lint and formatting errors without changing behavior.\n\n## Instructions\n- Run lint/check tasks\n- Apply minimal changes\n- Re-run lint\n",
        "docs-polish": "# Docs Polish\n\n## Purpose\nKeep documentation clear and up to date.\n\n## Instructions\n- Update README and changelogs as needed\n- Keep formatting consistent\n",
      };
      STATE.libraryEntries = entries;
      STATE.libraryContents = contents;
      return { entries: entries.length, scaffolded: 3 };
    }
    function formatLogLine(entry) {
      return `[${formatTimestamp(entry.ts)}] [${entry.level}] ${entry.source}: ${entry.msg}`;
    }

    function normalizeTaskStatusForCounts(status) {
      const raw = String(status || '').toLowerCase();
      if (['running', 'inprogress', 'active'].includes(raw)) return 'inprogress';
      if (['inreview', 'review'].includes(raw)) return 'inreview';
      if (['done', 'completed', 'merged'].includes(raw)) return 'done';
      if (['todo', 'queued', 'backlog'].includes(raw)) return 'todo';
      if (['draft', 'planned', 'planning'].includes(raw)) return 'draft';
      if (['error', 'failed', 'blocked', 'cancelled'].includes(raw)) return 'error';
      return raw || 'todo';
    }

    function buildTaskCounts() {
      const counts = {
        running: 0,
        inprogress: 0,
        inreview: 0,
        review: 0,
        done: 0,
        todo: 0,
        draft: 0,
        error: 0,
      };
      const tasks = Array.isArray(STATE.tasks) ? STATE.tasks : [];
      for (const task of tasks) {
        const status = normalizeTaskStatusForCounts(task?.status);
        if (status === 'inprogress') {
          counts.running += 1;
          counts.inprogress += 1;
        } else if (status === 'inreview') {
          counts.inreview += 1;
          counts.review += 1;
        } else if (Object.prototype.hasOwnProperty.call(counts, status)) {
          counts[status] += 1;
        }
      }
      return counts;
    }

    function buildStatusSnapshot() {
      const counts = buildTaskCounts();
      const tasks = Array.isArray(STATE.tasks) ? STATE.tasks : [];
      const withPr = tasks.filter((t) => t && t.pr != null);
      const merged = tasks.filter((t) => t?.status === 'done' && t?.pr != null);
      const pendingPr = withPr.length - merged.length;
      const active = counts.inprogress + counts.inreview;
      const queued = counts.todo + counts.draft;
      return {
        ...STATE.status,
        maxParallel: STATE.maxParallel,
        counts,
        tasks: {
          ...(STATE.status?.tasks || {}),
          completed: counts.done,
          failed: counts.error,
          active,
          queued,
        },
        prs: {
          ...(STATE.status?.prs || {}),
          created: withPr.length,
          merged: merged.length,
          pending: Math.max(0, pendingPr),
        },
        backlog_remaining: queued,
      };
    }

    function buildProjectSnapshot() {
      const tasks = Array.isArray(STATE.tasks) ? STATE.tasks : [];
      return {
        ...STATE.project,
        totalTasks: tasks.length,
        completedTasks: tasks.filter((t) => t?.status === 'done').length,
        activePRs: tasks.filter((t) => t?.pr != null && t?.status !== 'done').length,
      };
    }

    /* ═══════════════════════════════════════════════════════════════════
       LIVE SIMULATION ENGINE
       Autonomously drives tasks through the pipeline over ~5 minutes.
       Each task goes: todo → inprogress (agent claims, streams activity)
       → inreview (PR created, review workflow fires) → done (merged).
       ═══════════════════════════════════════════════════════════════════ */

    function appendMessage(session, msg) {
      if (!session || !msg) return false;
      const messages = Array.isArray(session.messages) ? session.messages : [];
      const content = String(msg.content || '').trim();
      const msgType = String(msg.type || '');
      const msgRole = String(msg.role || '');
      if (content && msgRole === 'system') {
        const duplicateSystem = messages.some((existing) =>
          String(existing?.role || '') === msgRole &&
          String(existing?.type || '') === msgType &&
          String(existing?.content || '').trim() === content);
        if (duplicateSystem) return false;
      }
      const last = messages[messages.length - 1] || null;
      if (last) {
        const sameContent = String(last.content || '').trim() === content && content.length > 0;
        const sameRole = String(last.role || '') === msgRole;
        const sameType = String(last.type || '') === msgType;
        const lastTs = Date.parse(last.timestamp || 0) || 0;
        const msgTs = Date.parse(msg.timestamp || 0) || 0;
        const isNearDuplicate = sameContent && sameRole && sameType && Math.abs(msgTs - lastTs) <= 5000;
        if (isNearDuplicate) return false;
      }
      session.messages.push(msg);
      session.updatedAt = Date.now();
      if (msg.content && msg.role !== 'system' && msg.type !== 'tool_call' && msg.type !== 'tool_result') {
        session.lastMessage = msg.content;
      }
      return true;
    }

    function buildDemoSlots() {
      const agents = Array.isArray(STATE.agents) ? STATE.agents : [];
      const sorted = agents.slice().sort((a, b) => (a.index ?? 0) - (b.index ?? 0));
      return sorted.map((agent, i) => ({
        index: agent.index ?? i,
        id: agent.id,
        agentInstanceId: agent.id,
        taskId: agent.taskId,
        taskTitle: agent.taskTitle,
        branch: agent.branch,
        status: agent.status || 'busy',
        sdk: agent.type || agent.sdk || 'codex',
        model: agent.model || 'o4-mini',
        sessionId: agent.sessionId || null,
        startedAt: agent.startedAt || Date.now() - (30 + i * 12) * min,
        lastHeartbeat: agent.lastHeartbeat || Date.now() - (10 + i * 5) * 1000,
        attempt: agent.attempt || 1,
        completedCount: agent.completedCount ?? (4 + i),
        avgDurationMs: agent.avgDurationMs ?? (12 + i * 5) * 60000,
        lastError: agent.lastError || null,
      }));
    }

    function buildContextForQuery(query) {
      const q = String(query || '').trim();
      if (!q) {
        return { query: q, context: null, diagnostics: { reasons: ['no-query'], hints: ['Provide a task id or branch name.'] } };
      }
      const queryLower = q.toLowerCase();
      const slots = buildDemoSlots();
      const slotMatch = slots.find((slot) => {
        const taskId = String(slot.taskId || '').toLowerCase();
        const branch = String(slot.branch || '').toLowerCase();
        const sessionId = String(slot.sessionId || '').toLowerCase();
        return taskId === queryLower || branch.includes(queryLower) || sessionId.includes(queryLower);
      });
      const sessionMatch = STATE.sessions.find((s) => {
        const id = String(s.id || '').toLowerCase();
        const taskId = String(s.taskId || '').toLowerCase();
        const branch = String(s.branch || '').toLowerCase();
        return id === queryLower || taskId === queryLower || branch.includes(queryLower);
      }) || null;
      const worktreeMatch = STATE.worktrees.find((w) => {
        const branch = String(w.branch || '').toLowerCase();
        const taskId = String(w.taskId || '').toLowerCase();
        return branch.includes(queryLower) || taskId === queryLower;
      }) || null;

      const sessionInfo = sessionMatch
        ? {
            id: sessionMatch.id,
            taskId: sessionMatch.taskId,
            status: sessionMatch.status,
            branch: sessionMatch.branch,
            preview: sessionMatch.lastMessage || '',
          }
        : null;
      const slotInfo = slotMatch
        ? {
            taskId: slotMatch.taskId,
            taskTitle: slotMatch.taskTitle,
            branch: slotMatch.branch,
            status: slotMatch.status,
            sdk: slotMatch.sdk,
            model: slotMatch.model,
            index: slotMatch.index,
          }
        : null;

      const matches = {
        worktrees: worktreeMatch
          ? [{ name: worktreeMatch.branch || worktreeMatch.taskId || 'worktree', path: worktreeMatch.path }]
          : [],
        slots: slotInfo ? [slotInfo] : [],
        sessions: sessionInfo ? [sessionInfo] : [],
      };

      const diff = sessionMatch ? (STATE.sessionDiffs[sessionMatch.id] || null) : null;
      const diffFiles = diff?.files || [];
      const changedFiles = diffFiles.map((file) => ({
        code: file.status === 'added' ? 'A' : file.status === 'removed' ? 'D' : 'M',
        file: file.filename,
      }));
      const gitStatus = changedFiles.map((file) => `${file.code} ${file.file}`).join('\n');
      const gitDiffStat = diffFiles.map((file) => {
        const delta = (file.additions || 0) + (file.deletions || 0);
        return `${file.filename} | ${delta} ${'+'.repeat(Math.min(5, file.additions || 0))}${'-'.repeat(Math.min(5, file.deletions || 0))}`;
      }).join('\n');
      const recentCommits = [
        { hash: 'c7d4e91', message: `Update ${sessionMatch?.title || 'workspace'}`, time: '2h ago' },
        { hash: '8a3f2c1', message: 'Add tests + tighten errors', time: '5h ago' },
        { hash: 'e39aa3c', message: 'Refactor UI layout', time: '1d ago' },
      ];
      const gitLogDetailed = recentCommits.map((c) => `${c.hash}||${c.message}||${c.time}`).join('\n');

      const context = sessionMatch || worktreeMatch
        ? {
            name: worktreeMatch?.branch || sessionMatch?.branch || q,
            path: worktreeMatch?.path || `/worktrees/${(sessionMatch?.branch || q).replace(/[^a-z0-9-]/gi, '-').toLowerCase()}`,
            gitBranch: worktreeMatch?.branch || sessionMatch?.branch || 'main',
            gitStatus,
            gitLogDetailed,
            gitDiffStat,
            gitAheadBehind: '1 0',
            changedFiles,
            recentCommits,
            diffSummary: gitDiffStat,
          }
        : null;

      const actionHistory = (sessionMatch?.messages || [])
        .filter((msg) => msg?.type === 'tool_call' || msg?.type === 'tool_result' || msg?.type === 'error')
        .slice(-12)
        .map((msg) => ({
          type: msg.type,
          tool: msg.meta?.toolName || (msg.type === 'tool_result' ? 'RESULT' : 'TOOL'),
          detail: msg.content || '',
          content: msg.content || '',
          timestamp: msg.timestamp || msg.createdAt || Date.now(),
        }));

      const fileAccessSummary = diffFiles.length
        ? {
            files: diffFiles.map((file) => ({ path: file.filename, kinds: ['write'] })),
            counts: { read: 0, write: diffFiles.length, other: 0 },
          }
        : null;

      const diagnostics = context || sessionInfo || slotInfo
        ? { searched: { activeSlots: slots.length, activeWorktrees: STATE.worktrees.length, sessions: STATE.sessions.length } }
        : {
            reasons: ['no-matching-slots-or-worktrees'],
            hints: ['Try a task id, branch name, or session id.'],
            searched: { activeSlots: slots.length, activeWorktrees: STATE.worktrees.length, sessions: STATE.sessions.length },
          };

      return {
        query: q,
        context,
        session: sessionInfo,
        slot: slotInfo,
        matches,
        diagnostics,
        actionHistory,
        fileAccessSummary,
      };
    }

    /* ── Agent action scripts: realistic sequences per task type ──── */
    const AGENT_SCRIPTS = {
      'bosun-12': [
        { type: 'tool_call', content: 'rg "error-cluster|correlat" bosun/ -n --type js' },
        { type: 'tool_result', content: 'bosun/anomaly-detector.mjs:89:  classifyError(pattern) {\nbosun/anomaly-detector.mjs:142:  // TODO: correlation report\nbosun/error-detector.mjs:34:  detectPattern(log) {' },
        { role: 'assistant', content: 'Found the anomaly detector with a TODO stub for correlation. I\'ll implement the error-cluster correlation report in `anomaly-detector.mjs` and wire it to the planning insights endpoint.' },
        { type: 'tool_call', content: 'cat bosun/anomaly-detector.mjs | head -160' },
        { type: 'tool_result', content: 'import { readFileSync } from "fs";\nimport { join } from "path";\n\nexport class AnomalyDetector {\n  constructor(config) {\n    this.patterns = new Map();\n    this.clusters = [];\n    ...\n  classifyError(pattern) {\n    const known = this.patterns.get(pattern.type);\n    return known ? { ...known, confidence: 0.92 } : null;\n  }\n  // TODO: correlation report' },
        { role: 'assistant', content: 'Implementing the correlation engine. It will group errors by pattern type, calculate temporal proximity, and output a planning-ready report.' },
        { type: 'tool_call', content: 'apply_patch bosun/anomaly-detector.mjs' },
        { type: 'tool_result', content: '✓ Applied patch to bosun/anomaly-detector.mjs (+67 lines)\n  Added: correlateErrors(), buildCorrelationReport()\n  Modified: constructor to init correlation window' },
        { type: 'tool_call', content: 'node --check bosun/anomaly-detector.mjs' },
        { type: 'tool_result', content: '(no output — syntax OK)' },
        { role: 'assistant', content: 'Core correlation engine implemented. Now writing tests.' },
        { type: 'tool_call', content: 'apply_patch bosun/tests/anomaly-detector.test.mjs' },
        { type: 'tool_result', content: '✓ Created bosun/tests/anomaly-detector.test.mjs (+48 lines)\n  Tests: correlateErrors groups by pattern, buildCorrelationReport output shape, empty input returns empty report' },
        { type: 'tool_call', content: 'npx vitest run tests/anomaly-detector.test.mjs' },
        { type: 'tool_result', content: '✓ tests/anomaly-detector.test.mjs (3 tests) 142ms\n  ✓ correlateErrors groups by pattern\n  ✓ buildCorrelationReport output shape\n  ✓ empty input returns empty report\n\n Test Files  1 passed (1)\n      Tests  3 passed (3)' },
        { role: 'assistant', content: 'All tests passing. Handing off PR lifecycle to Bosun.' },
        { type: 'tool_call', content: 'git add -A && git commit -m "feat(analytics): error-cluster correlation report for planning insights"' },
        { type: 'tool_result', content: '[bs/12-error-correlation 8a3f2c1] feat(analytics): error-cluster correlation report for planning insights\n 2 files changed, 115 insertions(+)' },
        { type: 'tool_call', content: 'echo "Bosun PR lifecycle handoff: feat(analytics): error-cluster correlation report (branch bs/12-error-correlation)"' },
        { type: 'tool_result', content: 'Lifecycle handoff recorded for bs/12-error-correlation. Bosun manager will open and maintain the PR.' },
        { role: 'assistant', content: 'Lifecycle handoff recorded. Moving to review.' },
      ],
      'bosun-11': [
        { type: 'tool_call', content: 'rg "session.*metadata|VK.*API|enrichSession" bosun/ -n --type js' },
        { type: 'tool_result', content: 'bosun/session-tracker.mjs:18:  enrichSession(session) {\nbosun/session-tracker.mjs:22:    // TODO: fetch from VK API when fields are missing\nbosun/telegram-bot.mjs:341:  const userInfo = await this.getVKUserInfo(userId);' },
        { role: 'assistant', content: 'Found the session tracker with a VK API enrichment stub. I\'ll implement the metadata enrichment flow — fetch missing user info from Telegram/VK API and backfill session records.' },
        { type: 'tool_call', content: 'cat bosun/session-tracker.mjs' },
        { type: 'tool_result', content: 'export class SessionTracker {\n  constructor(opts) { this.maxMessages = opts?.maxMessages || 10; }\n  enrichSession(session) {\n    if (session.user?.firstName) return session;\n    // TODO: fetch from VK API when fields are missing\n    return session;\n  }\n  ...\n}' },
        { role: 'assistant', content: 'I\'ll add the VK API client call with a cache layer so we don\'t hit rate limits. Adding retry + fallback logic.' },
        { type: 'tool_call', content: 'apply_patch bosun/session-tracker.mjs' },
        { type: 'tool_result', content: '✓ Applied patch to bosun/session-tracker.mjs (+42 lines)\n  Added: async enrichSessionFromAPI(), LRU cache for user lookups\n  Modified: enrichSession() to call API when fields missing' },
        { type: 'tool_call', content: 'npx vitest run tests/session-tracker.test.mjs' },
        { type: 'tool_result', content: '✓ tests/session-tracker.test.mjs (6 tests) 89ms\n  ✓ enriches session with VK API data\n  ✓ caches user lookups\n  ✓ handles API failure gracefully\n\n Test Files  1 passed (1)\n      Tests  6 passed (6)' },
        { role: 'assistant', content: 'All tests pass. Committing and handing off PR lifecycle.' },
        { type: 'tool_call', content: 'git add -A && git commit -m "feat(session): enrich metadata from VK API when missing"' },
        { type: 'tool_result', content: '[bs/11-agent-logging-enrich c7d4e91] feat(session): enrich metadata from VK API when missing\n 2 files changed, 58 insertions(+), 3 deletions(-)' },
        { type: 'tool_call', content: 'echo "Bosun PR lifecycle handoff: feat(session): enrich metadata from VK API (branch bs/11-agent-logging-enrich)"' },
        { type: 'tool_result', content: 'Lifecycle handoff recorded for bs/11-agent-logging-enrich. Bosun manager will open and maintain the PR.' },
        { role: 'assistant', content: 'Lifecycle handoff recorded for issue #11. Moving to review.' },
      ],
      've-760': [
        { type: 'tool_call', content: 'rg "ProcessOrder|OrderExpir" x/market/keeper -n' },
        { type: 'tool_result', content: 'x/market/keeper/order.go:118:func (k Keeper) ProcessOrder(ctx sdk.Context, order Order) error {\nx/market/keeper/order.go:145:  // TODO: implement expiry check\nx/market/types/order.go:24:  ExpiresAt time.Time' },
        { role: 'assistant', content: 'Found the order processor with an expiry TODO. The `ExpiresAt` field already exists on the Order type. I\'ll wire the TTL check and auto-settlement logic.' },
        { type: 'tool_call', content: 'apply_patch x/market/keeper/order.go' },
        { type: 'tool_result', content: '✓ Applied patch to x/market/keeper/order.go (+38 lines)\n  Added: expiry check in ProcessOrder, SettleExpiredOrder helper\n  Modified: ProcessOrder to call expiry before matching' },
        { type: 'tool_call', content: 'apply_patch x/market/keeper/order_test.go' },
        { type: 'tool_result', content: '✓ Created x/market/keeper/order_test.go (+92 lines)\n  Tests: TestOrderExpiry, TestAutoSettlement, TestExpiredOrderCancellation' },
        { type: 'tool_call', content: 'go test ./x/market/keeper/... -v -count=1' },
        { type: 'tool_result', content: '=== RUN   TestOrderExpiry\n--- PASS: TestOrderExpiry (0.02s)\n=== RUN   TestAutoSettlement\n--- PASS: TestAutoSettlement (0.01s)\n=== RUN   TestExpiredOrderCancellation\n--- PASS: TestExpiredOrderCancellation (0.01s)\nPASS\nok  \tvirtengine/x/market/keeper\t0.142s' },
        { role: 'assistant', content: 'All market keeper tests pass. Committing.' },
        { type: 'tool_call', content: 'git add -A && git commit -m "feat(market): order expiry and auto-settlement"' },
        { type: 'tool_result', content: '[ve/760-market-order-expiry d2e8f3a] feat(market): order expiry and auto-settlement\n 2 files changed, 130 insertions(+), 2 deletions(-)' },
        { type: 'tool_call', content: 'echo "Bosun PR lifecycle handoff: feat(market): order expiry and auto-settlement (branch ve/760-market-order-expiry)"' },
        { type: 'tool_result', content: 'Lifecycle handoff recorded for ve/760-market-order-expiry. Bosun manager will open and maintain the PR.' },
        { role: 'assistant', content: 'Lifecycle handoff recorded on virtengine/virtengine. CI monitoring active.' },
      ],
      've-761': [
        { type: 'tool_call', content: 'rg "BatchSettle|settlement.*batch" x/escrow -n' },
        { type: 'tool_result', content: 'x/escrow/keeper/batch.go:12:func (k Keeper) BatchSettle(ctx sdk.Context) error {\nx/escrow/keeper/batch.go:14:  iter := k.store.Iterator(ctx, k.settlementPrefix)\nx/escrow/keeper/msg_server.go:118:  // TODO: wire batch settlement' },
        { role: 'assistant', content: 'The batch iterator skeleton exists but msg_server isn\'t wired. I\'ll complete the batch pipeline — add the retry guard, wire it into the message handler, and add integration tests.' },
        { type: 'tool_call', content: 'apply_patch x/escrow/keeper/batch.go' },
        { type: 'tool_result', content: '✓ Applied patch to x/escrow/keeper/batch.go (+53 lines)\n  Added: retryGuard, per-item error handling, metrics emission\n  Modified: BatchSettle to use retry guard and emit metrics' },
        { type: 'tool_call', content: 'apply_patch x/escrow/keeper/msg_server.go' },
        { type: 'tool_result', content: '✓ Applied patch to x/escrow/keeper/msg_server.go (+12 lines)\n  Modified: TriggerSettlement to call BatchSettle with context' },
        { type: 'tool_call', content: 'go test ./x/escrow/... -v -count=1' },
        { type: 'tool_result', content: '=== RUN   TestBatchSettle\n--- PASS: TestBatchSettle (0.03s)\n=== RUN   TestBatchSettleRetry\n--- PASS: TestBatchSettleRetry (0.02s)\n=== RUN   TestTriggerSettlement\n--- PASS: TestTriggerSettlement (0.01s)\nPASS\nok  \tvirtengine/x/escrow/keeper\t0.198s' },
        { role: 'assistant', content: 'Escrow batch pipeline complete. All tests green. Handing off PR lifecycle.' },
        { type: 'tool_call', content: 'git add -A && git commit -m "refactor(escrow): batch settlement pipeline with retry guard"' },
        { type: 'tool_result', content: '[ve/761-escrow-batch a4b9c12] refactor(escrow): batch settlement pipeline with retry guard\n 3 files changed, 98 insertions(+), 8 deletions(-)' },
        { type: 'tool_call', content: 'echo "Bosun PR lifecycle handoff: refactor(escrow): batch settlement pipeline (branch ve/761-escrow-batch)"' },
        { type: 'tool_result', content: 'Lifecycle handoff recorded for ve/761-escrow-batch. Bosun manager will open and maintain the PR.' },
        { role: 'assistant', content: 'Lifecycle handoff recorded. Moving to review.' },
      ],
      've-763': [
        { type: 'tool_call', content: 'rg "GPUMeter|TrackGPU|gpu.*resource" x/hpc -n' },
        { type: 'tool_result', content: 'x/hpc/keeper/metering.go:44:func (k Keeper) TrackGPU(ctx sdk.Context, pod Pod) error {\nx/hpc/types/config.go:18:  GPUMeteringEnabled bool' },
        { role: 'assistant', content: 'GPU metering hooks exist but have no tests. I\'ll write comprehensive unit tests covering the metering flow, config toggle, and edge cases.' },
        { type: 'tool_call', content: 'apply_patch x/hpc/keeper/metering_test.go' },
        { type: 'tool_result', content: '✓ Created x/hpc/keeper/metering_test.go (+78 lines)\n  Tests: TestTrackGPU, TestGPUMeteringDisabled, TestMeteringOverflow, TestMeteringMultiplePods' },
        { type: 'tool_call', content: 'go test ./x/hpc/... -v -count=1' },
        { type: 'tool_result', content: '=== RUN   TestTrackGPU\n--- PASS: TestTrackGPU (0.01s)\n=== RUN   TestGPUMeteringDisabled\n--- PASS: TestGPUMeteringDisabled (0.00s)\n=== RUN   TestMeteringOverflow\n--- PASS: TestMeteringOverflow (0.01s)\n=== RUN   TestMeteringMultiplePods\n--- PASS: TestMeteringMultiplePods (0.02s)\nPASS\nok  \tvirtengine/x/hpc/keeper\t0.089s' },
        { role: 'assistant', content: 'All 4 GPU metering tests pass. Committing and handing off PR lifecycle.' },
        { type: 'tool_call', content: 'git add -A && git commit -m "test(hpc): GPU resource metering unit tests"' },
        { type: 'tool_result', content: '[ve/763-gpu-metering-tests e5f1d23] test(hpc): GPU resource metering unit tests\n 1 file changed, 78 insertions(+)' },
        { type: 'tool_call', content: 'echo "Bosun PR lifecycle handoff: test(hpc): GPU resource metering unit tests (branch ve/763-gpu-metering-tests)"' },
        { type: 'tool_result', content: 'Lifecycle handoff recorded for ve/763-gpu-metering-tests. Bosun manager will open and maintain the PR.' },
        { role: 'assistant', content: 'Lifecycle handoff recorded. Tests-only change should review quickly.' },
      ],
    };

    /* ── Review scripts: what happens during inreview ──────────────── */
    const REVIEW_SCRIPTS = {
      'bosun-12': [
        { role: 'assistant', content: '[review-agent] Reviewing PR #19 — feat(analytics): error-cluster correlation report' },
        { type: 'tool_call', content: 'gh pr diff 19 --stat' },
        { type: 'tool_result', content: ' bosun/anomaly-detector.mjs           | 67 ++++++++++++++\n bosun/tests/anomaly-detector.test.mjs | 48 ++++++++++\n 2 files changed, 115 insertions(+)' },
        { role: 'assistant', content: 'Code looks good — clean separation, tests cover edge cases. Approving.' },
        { type: 'tool_call', content: 'gh pr review 19 --approve -b "LGTM — correlation engine is well-structured"' },
        { type: 'tool_result', content: '✓ Approved PR #19' },
        { type: 'tool_call', content: 'gh pr merge 19 --squash --auto' },
        { type: 'tool_result', content: '✓ PR #19 merged via squash' },
      ],
      'bosun-11': [
        { role: 'assistant', content: '[review-agent] Reviewing PR #20 — feat(session): enrich metadata from VK API' },
        { type: 'tool_call', content: 'gh pr checks 20' },
        { type: 'tool_result', content: 'All checks passed\n✓ syntax-check  ✓ vitest  ✓ build' },
        { role: 'assistant', content: 'CI green. Code review: cache layer is solid, graceful degradation on API failure. Approving.' },
        { type: 'tool_call', content: 'gh pr review 20 --approve' },
        { type: 'tool_result', content: '✓ Approved PR #20' },
        { type: 'tool_call', content: 'gh pr merge 20 --squash --auto' },
        { type: 'tool_result', content: '✓ PR #20 merged via squash' },
      ],
      've-760': [
        { role: 'assistant', content: '[review-agent] Reviewing PR #765 — feat(market): order expiry and auto-settlement' },
        { type: 'tool_call', content: 'gh pr checks 765' },
        { type: 'tool_result', content: 'All checks passed\n✓ golangci-lint  ✓ go test  ✓ protobuf-check' },
        { role: 'assistant', content: 'CI passed. Market keeper changes are clean — expiry logic is solid with proper test coverage. Approving.' },
        { type: 'tool_call', content: 'gh pr review 765 --approve -b "Clean implementation, good test coverage"' },
        { type: 'tool_result', content: '✓ Approved PR #765' },
        { type: 'tool_call', content: 'gh pr merge 765 --squash --auto' },
        { type: 'tool_result', content: '✓ PR #765 merged via squash' },
      ],
      've-761': [
        { role: 'assistant', content: '[review-agent] Reviewing PR #766 — refactor(escrow): batch settlement pipeline' },
        { type: 'tool_call', content: 'gh pr diff 766 --stat' },
        { type: 'tool_result', content: ' x/escrow/keeper/batch.go       | 53 +++++++++++++\n x/escrow/keeper/msg_server.go   | 12 ++++\n x/escrow/keeper/batch_test.go   | 33 ++++++++\n 3 files changed, 98 insertions(+), 8 deletions(-)' },
        { role: 'assistant', content: 'Retry guard pattern is good. One minor suggestion: add context timeout. Approving with comment.' },
        { type: 'tool_call', content: 'gh pr review 766 --approve' },
        { type: 'tool_result', content: '✓ Approved PR #766' },
        { type: 'tool_call', content: 'gh pr merge 766 --squash --auto' },
        { type: 'tool_result', content: '✓ PR #766 merged via squash' },
      ],
      've-763': [
        { role: 'assistant', content: '[review-agent] Reviewing PR #767 — test(hpc): GPU resource metering unit tests' },
        { type: 'tool_call', content: 'gh pr checks 767' },
        { type: 'tool_result', content: 'All checks passed\n✓ golangci-lint  ✓ go test' },
        { role: 'assistant', content: 'Tests-only PR, all green. Quick approve.' },
        { type: 'tool_call', content: 'gh pr review 767 --approve' },
        { type: 'tool_result', content: '✓ Approved PR #767' },
        { type: 'tool_call', content: 'gh pr merge 767 --squash --auto' },
        { type: 'tool_result', content: '✓ PR #767 merged via squash' },
      ],
    };

    /* ── Live log buffer: meaningful, timestamped log entries ──────── */
    const liveLogBuffer = [];
    function pushLiveLog(level, source, msg) {
      const entry = { ts: Date.now(), level, source, msg };
      liveLogBuffer.push(entry);
      if (liveLogBuffer.length > 200) liveLogBuffer.shift();
      addLog(level, source, msg);
      // Push via any open WS
      if (_demoWS && _demoWS.onmessage) {
        _demoWS.onmessage({ data: JSON.stringify({ type: 'log', entry }) });
      }
    }

    /* ── WebSocket reference for pushing events ───────────────────── */
    let _demoWS = null;

    /* ── Task lifecycle simulation ────────────────────────────────── */
    const TASK_QUEUE = ['bosun-12', 'bosun-11', 've-760', 've-761', 've-763'];
    let simIdx = 0;
    let simRunning = false;
    const activeSims = new Map(); // taskId → { phase, stepIdx, timer }

    function getOrCreateSession(taskId) {
      const task = findTask(taskId);
      if (!task) return null;
      let session = STATE.sessions.find(s => s.taskId === taskId && s.status !== 'archived');
      if (!session) {
        const id = 'ses-sim-' + taskId;
        session = {
          id, title: task.title, type: 'task', status: 'running',
          taskId, branch: task.branch || `sim/${taskId}`,
          createdAt: Date.now(), updatedAt: Date.now(),
          lastMessage: 'Session initialized.',
          messages: [makeMsg('system', `Session started for ${taskId}: ${task.title}`, Date.now(), 'system')],
        };
        STATE.sessions.unshift(session);
        STATE.sessionDiffs[id] = { files: [] };
      }
      return session;
    }

    function assignAgent(taskId) {
      const agents = ['copilot-claude', 'codex-default'];
      return agents[simIdx % agents.length];
    }

    function startTaskSim(taskId) {
      if (activeSims.has(taskId)) return;
      const task = findTask(taskId);
      if (!task) return;

      const agent = assignAgent(taskId);
      task.status = 'inprogress';
      task.assignee = agent;
      task.branch = task.branch || `sim/${taskId}`;
      task.updated = Date.now();

      const session = getOrCreateSession(taskId);
      const script = AGENT_SCRIPTS[taskId] || [];
      const repo = task.repo === 'virtengine' ? 'virtengine/virtengine' : 'virtengine/bosun';

      pushLiveLog('info', 'task-executor', `Claiming task ${taskId}: ${task.title}`);
      pushLiveLog('info', 'worktree', `Created worktree for branch ${task.branch}`);
      pushLiveLog('info', agent, `Starting work on ${taskId} (${repo})`);

      // Push task-update via WS
      if (_demoWS && _demoWS.onmessage) {
        _demoWS.onmessage({ data: JSON.stringify({ type: 'task-update', task: { id: taskId, status: 'inprogress' } }) });
      }

      const sim = { phase: 'work', stepIdx: 0, timer: null };
      activeSims.set(taskId, sim);

      function nextStep() {
        const s = activeSims.get(taskId);
        if (!s || s.stepIdx >= script.length) {
          // Done with work phase → move to review
          moveToReview(taskId);
          return;
        }
        const step = script[s.stepIdx];
        s.stepIdx++;

        const msg = makeMsg(step.role || 'assistant', step.content, Date.now(), step.type);
        appendMessage(session, msg);

        // Generate corresponding log
        if (step.type === 'tool_call') {
          pushLiveLog('info', agent, `[${taskId}] $ ${step.content.substring(0, 80)}`);
        } else if (step.type === 'tool_result') {
          const firstLine = step.content.split('\n')[0].substring(0, 100);
          pushLiveLog('debug', agent, `[${taskId}] → ${firstLine}`);
        } else {
          pushLiveLog('info', agent, `[${taskId}] ${step.content.substring(0, 100)}`);
        }

        // Push live WS events for UI reactivity
        if (_demoWS && _demoWS.onmessage) {
          // session-message so agent status indicator updates (executing/streaming)
          _demoWS.onmessage({ data: JSON.stringify({
            type: 'session-message',
            payload: { session: { id: session.id, type: 'task', status: 'active' }, message: msg },
          }) });
          // session-update for session list
          _demoWS.onmessage({ data: JSON.stringify({
            type: 'session-update',
            session: { id: session.id, taskId, lastMessage: session.lastMessage, updatedAt: session.updatedAt },
          }) });
          // invalidate so the active tab refreshes its data
          _demoWS.onmessage({ data: JSON.stringify({
            type: 'invalidate', channels: ['tasks', 'agents', 'overview'],
          }) });
        }

        // Schedule next step with realistic timing
        const delay = step.type === 'tool_call' ? (800 + Math.random() * 1200)
          : step.type === 'tool_result' ? (400 + Math.random() * 600)
          : (1500 + Math.random() * 2000);
        s.timer = setTimeout(nextStep, delay);
      }

      // Start first step after a short delay
      sim.timer = setTimeout(nextStep, 1000 + Math.random() * 1500);
    }

    function moveToReview(taskId) {
      const task = findTask(taskId);
      if (!task) return;
      const session = STATE.sessions.find(s => s.taskId === taskId && s.status === 'running');

      task.status = 'inreview';
      task.updated = Date.now();

      pushLiveLog('success', 'task-executor', `Task ${taskId} moved to review`);
      pushLiveLog('info', 'review-agent', `Starting automated review of ${taskId}`);

      if (_demoWS && _demoWS.onmessage) {
        _demoWS.onmessage({ data: JSON.stringify({ type: 'task-update', task: { id: taskId, status: 'inreview' } }) });
        _demoWS.onmessage({ data: JSON.stringify({ type: 'invalidate', channels: ['tasks', 'overview'] }) });
      }

      // Trigger workflow run
      const wfRun = {
        runId: 'run-' + Math.random().toString(36).slice(2, 6),
        workflowId: 'wf-pr-merge-auto',
        status: 'running',
        nodeCount: 6,
        duration: 0,
        errorCount: 0,
        startedAt: new Date().toISOString(),
      };
      STATE.workflowRuns.unshift(wfRun);
      pushLiveLog('info', 'workflow', `PR Merge Strategy workflow triggered for ${taskId} (${wfRun.runId})`);

      // Run review script
      const reviewScript = REVIEW_SCRIPTS[taskId] || [];
      const sim = activeSims.get(taskId) || { phase: 'review', stepIdx: 0, timer: null };
      sim.phase = 'review';
      sim.stepIdx = 0;
      activeSims.set(taskId, sim);

      let reviewDelay = 3000 + Math.random() * 3000; // Wait before review starts
      reviewScript.forEach((step, i) => {
        setTimeout(() => {
          if (session) {
            appendMessage(session, makeMsg(step.role || 'assistant', step.content, Date.now(), step.type));
          }
          if (step.type === 'tool_call') {
            pushLiveLog('info', 'review-agent', `[${taskId}] $ ${step.content.substring(0, 80)}`);
          } else if (step.type === 'tool_result') {
            pushLiveLog('debug', 'review-agent', `[${taskId}] → ${step.content.split('\\n')[0].substring(0, 80)}`);
          } else {
            pushLiveLog('info', 'review-agent', `[${taskId}] ${step.content.substring(0, 100)}`);
          }

          // Last step = merge → move to done
          if (i === reviewScript.length - 1) {
            setTimeout(() => moveToComplete(taskId, wfRun), 2000 + Math.random() * 2000);
          }
        }, reviewDelay);
        reviewDelay += step.type === 'tool_result' ? (300 + Math.random() * 400) : (1500 + Math.random() * 2000);
      });

      // Fallback if no review script
      if (reviewScript.length === 0) {
        setTimeout(() => moveToComplete(taskId, wfRun), 8000 + Math.random() * 5000);
      }
    }

    function moveToComplete(taskId, wfRun) {
      const task = findTask(taskId);
      if (!task) return;

      task.status = 'done';
      task.updated = Date.now();
      task.mergedAt = Date.now();

      // Update workflow run
      if (wfRun) {
        wfRun.status = 'completed';
        wfRun.duration = Date.now() - new Date(wfRun.startedAt).getTime();
      }

      // Update session
      const session = STATE.sessions.find(s => s.taskId === taskId);
      if (session) {
        session.status = 'completed';
        appendMessage(session, makeMsg('system', `Task ${taskId} completed — PR merged to main.`, Date.now(), 'system'));
      }

      pushLiveLog('success', 'kanban', `Task ${taskId} completed — PR merged`);
      pushLiveLog('success', 'git', `Branch ${task.branch} merged and deleted`);
      pushLiveLog('info', 'worktree', `Cleaned up worktree for ${task.branch}`);

      if (_demoWS && _demoWS.onmessage) {
        _demoWS.onmessage({ data: JSON.stringify({ type: 'invalidate', channels: ['tasks', 'overview', 'agents'] }) });
        _demoWS.onmessage({ data: JSON.stringify({ type: 'task-update', task: { id: taskId, status: 'done' } }) });
      }

      activeSims.delete(taskId);

      // Pick up next task from queue
      scheduleNextTask();
    }

    function scheduleNextTask() {
      if (simIdx >= TASK_QUEUE.length) {
        pushLiveLog('info', 'task-executor', 'Backlog empty — all queued tasks dispatched');
        return;
      }
      const nextTaskId = TASK_QUEUE[simIdx];
      simIdx++;
      const delay = 5000 + Math.random() * 10000; // 5-15s between task pickups
      pushLiveLog('info', 'task-executor', `Next task ${nextTaskId} scheduled for pickup in ${Math.round(delay/1000)}s`);
      setTimeout(() => startTaskSim(nextTaskId), delay);
    }

    /* ── Start the simulation loop ────────────────────────────────── */
    function startSimulation() {
      if (simRunning) return;
      simRunning = true;
      pushLiveLog('info', 'monitor', 'Fleet simulation started — processing backlog');
      pushLiveLog('info', 'monitor', `${TASK_QUEUE.length} tasks queued for processing`);

      // Executor heartbeat
      setInterval(() => {
        const load1 = 40 + Math.floor(Math.random() * 35);
        const load2 = 30 + Math.floor(Math.random() * 30);
        if (_demoWS && _demoWS.onmessage) {
          _demoWS.onmessage({ data: JSON.stringify({ type: 'executor-update', executor: { name: 'copilot-claude', load: load1 } }) });
          setTimeout(() => {
            if (_demoWS && _demoWS.onmessage) {
              _demoWS.onmessage({ data: JSON.stringify({ type: 'executor-update', executor: { name: 'codex-default', load: load2 } }) });
            }
          }, 2000);
        }
        pushLiveLog('info', 'monitor', `Health check passed — copilot-claude: ${load1}% · codex-default: ${load2}%`);
      }, 15000);

      // Start first two tasks in parallel (simulating max-parallel=2)
      startTaskSim(TASK_QUEUE[0]);
      simIdx = 1;
      setTimeout(() => {
        if (simIdx < TASK_QUEUE.length) {
          startTaskSim(TASK_QUEUE[simIdx]);
          simIdx++;
        }
      }, 3000 + Math.random() * 4000);
    }

    // Boot the simulation after a short delay (let the UI load first)
    setTimeout(startSimulation, 2500);

    const ASK_SCRIPT = [
      { role: 'assistant', content: 'Short answer: I can help with that quickly. Here is the key takeaway and the safest next step.' },
      { role: 'assistant', content: 'Want a deeper dive or a patch? Tell me your constraints and I’ll expand.' },
    ];

    const PLAN_SCRIPT = [
      {
        role: 'assistant',
        content: [
          'Plan:',
          '1. Confirm the target behavior and constraints.',
          '2. Identify the minimal code paths and add tests first.',
          '3. Implement the change with guard rails.',
          '4. Validate locally and summarize next steps.',
        ].join('\n'),
      },
    ];

    function enqueueScriptSteps(session, steps) {
      let delay = 600;
      steps.forEach((step) => {
        setTimeout(() => {
          appendMessage(session, makeMsg(step.role || 'assistant', step.content, Date.now(), step.type));
          pushLiveLog('info', 'agent', `${session.title}: ${step.type || 'message'}`);
        }, delay);
        delay += 900 + Math.random() * 900;
      });
    }

    /* ── User-initiated chat still works via scheduleResponses ─────── */
    function scheduleResponses(session, payloadMode) {
      const mode = String(payloadMode || session?.metadata?.mode || STATE.agentMode || 'agent').toLowerCase();
      if (mode === 'ask') {
        enqueueScriptSteps(session, ASK_SCRIPT);
        return;
      }
      if (mode === 'plan') {
        enqueueScriptSteps(session, PLAN_SCRIPT);
        return;
      }
      // For agent mode, pick the task's script or generic response
      const taskId = session.taskId;
      const script = AGENT_SCRIPTS[taskId];
      if (script && script.length > 0) {
        const steps = script.slice(0, 3);
        enqueueScriptSteps(session, steps);
      } else {
        setTimeout(() => {
          appendMessage(session, makeMsg('assistant', 'Acknowledged. I\'ll look into that and report back.', Date.now()));
          pushLiveLog('info', 'agent', `${session.title}: response sent`);
        }, 800 + Math.random() * 600);
      }
    }

    /* ── API Route Handler (comprehensive — catches ALL /api/* calls) */
    async function handleApi(path, method, body) {
      // Normalize: strip query string for route matching
      const [route, qs] = path.split('?');
      const params = new URLSearchParams(qs || '');

      // ── Status & Executor ──
      if (route === '/api/status')
        return { data: buildStatusSnapshot() };
      if (route === '/api/executor') {
        const statusSnapshot = buildStatusSnapshot();
        const slots = buildDemoSlots();
        const activeSlots = slots.filter((slot) => ['running', 'busy'].includes(String(slot.status || '').toLowerCase())).length;
        return {
          data: {
            ...statusSnapshot,
            maxParallel: STATE.maxParallel,
            paused: STATE.paused,
            executors: STATE.executors,
            activeSlots,
            slots,
            sdk: 'auto',
          },
        };
      }
      if (!STATE.triggerTemplates) {
        STATE.triggerTemplates = {
          enabled: false,
          defaults: { executor: 'auto', model: 'auto' },
          planner: { lastSuccessAt: null, lastFailureAt: null, lastError: null },
          templates: [
            {
              id: 'task-planner',
              name: 'Task Planner',
              description: 'Create planning tasks when backlog is low.',
              enabled: false,
              action: 'task-planner',
              minIntervalMinutes: 360,
              trigger: { anyOf: [{ kind: 'metric', metric: 'backlogRemaining', operator: 'eq', value: 0 }] },
              config: { plannerMode: 'kanban', defaultTaskCount: 30, executor: 'auto', model: 'auto' },
              state: { last_success_at: null, last_error: null },
              stats: { spawnedTotal: 0, activeCount: 0, doneCount: 0, runningAgents: [], recentSpawned: [] },
            },
            {
              id: 'daily-review-digest',
              name: 'Daily Review Digest',
              description: 'Create a daily review digest task.',
              enabled: false,
              action: 'create-task',
              minIntervalMinutes: 1440,
              trigger: { anyOf: [{ kind: 'interval', minutes: 1440 }] },
              config: { title: '[m] Daily review digest', priority: 'medium', executor: 'auto', model: 'auto' },
              state: { last_success_at: null, last_error: null },
              stats: { spawnedTotal: 0, activeCount: 0, doneCount: 0, runningAgents: [], recentSpawned: [] },
            },
          ],
        };
      }
      if (route === '/api/triggers/templates') {
        return { ok: true, data: STATE.triggerTemplates };
      }
      if (route === '/api/triggers/templates/update') {
        if (typeof body?.enabled === 'boolean') STATE.triggerTemplates.enabled = body.enabled;
        if (body?.defaults && typeof body.defaults === 'object') {
          STATE.triggerTemplates.defaults = { ...STATE.triggerTemplates.defaults, ...body.defaults };
        }
        if (body?.template && body.template.id) {
          const idx = STATE.triggerTemplates.templates.findIndex((t) => t.id === body.template.id);
          if (idx >= 0) STATE.triggerTemplates.templates[idx] = { ...STATE.triggerTemplates.templates[idx], ...body.template };
          else STATE.triggerTemplates.templates.push(body.template);
        }
        addLog('info', 'config', 'Trigger templates updated');
        return { ok: true, data: STATE.triggerTemplates };
      }
      if (route === '/api/telemetry/summary')
        return { data: { status: 'ok', updatedAt: Date.now(), totals: { tasks: STATE.tasks.length, executors: STATE.executors.length } } };
      if (route === '/api/telemetry/errors')
        return { data: [] };
      if (route === '/api/telemetry/executors')
        return { data: STATE.executors.map((e) => ({ ...e, status: e.enabled ? 'active' : 'disabled' })) };
      if (route === '/api/telemetry/alerts')
        return { data: [] };
      if (route === '/api/executor/pause') {
        STATE.paused = true; addLog('info', 'executor', 'Executor paused');
        return { ok: true, paused: true };
      }
      if (route === '/api/executor/resume') {
        STATE.paused = false; addLog('info', 'executor', 'Executor resumed');
        return { ok: true, paused: false };
      }
      if (route === '/api/executor/maxparallel') {
        const mp = body?.maxParallel ?? STATE.maxParallel;
        STATE.maxParallel = mp; STATE.status.maxParallel = mp;
        addLog('info', 'executor', `Max parallel set to ${mp}`);
        return { ok: true, maxParallel: mp };
      }
      if (route === '/api/executor/stop-slot') {
        addLog('info', 'executor', `Slot stopped: ${body?.slotId || 'unknown'}`);
        return { ok: true };
      }
      if (route === '/api/executor/dispatch') {
        addLog('info', 'executor', `Manual dispatch: ${body?.taskId || 'unknown'}`);
        return { ok: true, dispatched: body?.taskId };
      }

      // ── Tasks ──
      if (route === '/api/tasks') {
        let tasks = [...STATE.tasks];
        const status = params.get('status');
        const priority = params.get('priority');
        const search = params.get('search');
        const sort = params.get('sort');
        if (status && status !== 'all') tasks = tasks.filter(t => t.status === status);
        if (priority && priority !== 'all') tasks = tasks.filter(t => t.priority === priority);
        if (search) tasks = tasks.filter(t => t.title.toLowerCase().includes(search.toLowerCase()));
        if (sort === 'priority') tasks.sort((a, b) => { const o = {critical:0,high:1,medium:2,low:3}; return (o[a.priority]??9)-(o[b.priority]??9); });
        if (sort === '-updated') tasks.sort((a, b) => b.updated - a.updated);
        const page = parseInt(params.get('page')) || 1;
        const pageSize = parseInt(params.get('pageSize') || params.get('limit')) || 50;
        const total = tasks.length;
        const paged = tasks.slice((page-1)*pageSize, page*pageSize);
        return { data: paged, tasks: paged, total, totalPages: Math.max(1, Math.ceil(total/pageSize)), page, pageSize };
      }
      if (route === '/api/tasks/detail') {
        const t = findTask(params.get('taskId'));
        return { data: t || null };
      }
      if (route === '/api/tasks/attachments/upload') {
        const taskId = body?.taskId || body?.id || params.get('taskId');
        const t = findTask(taskId);
        if (!t) return { ok: false, error: 'Task not found' };
        const files = Array.isArray(body?.files) ? body.files : [];
        const added = files.length
          ? files.map((file) => makeAttachment(file.name, file.type?.startsWith('image/') ? 'image' : 'file', file.type, file.size))
          : [makeAttachment()];
        const current = Array.isArray(t.attachments) ? t.attachments : [];
        t.attachments = [...current, ...added];
        t.meta = { ...(t.meta || {}), attachments: t.attachments };
        t.updated = Date.now();
        addLog('info', 'tasks', `Attachment uploaded: ${t.title}`);
        return { ok: true, taskId: t.id, backend: t.backend || 'demo', added, attachments: t.attachments };
      }
      if (route === '/api/tasks/create') {
        const id = 've-' + Math.random().toString(36).slice(2, 8);
        const t = { id, title: body?.title || 'New task', status: 'todo', priority: body?.priority || 'medium', assignee: null, branch: null, pr: null, created: Date.now(), updated: Date.now() };
        STATE.tasks.unshift(t); addLog('success', 'kanban', `Task created: ${t.title}`);
        return { ok: true, data: t };
      }
      if (route === '/api/tasks/rewrite') {
        const origTitle = String(body?.title || '').trim();
        const origDesc = String(body?.description || '').trim();
        await new Promise(r => setTimeout(r, 800)); // simulate AI latency
        const rewrittenDesc = [
          '## Background',
          `${origDesc || 'No description provided — details inferred from title.'}`,
          '',
          '## Acceptance Criteria',
          '- [ ] Feature works end-to-end without regressions',
          '- [ ] Unit tests cover the new logic',
          '- [ ] UI feedback is clear (loading states, errors, success toasts)',
          '',
          '## Implementation Steps',
          '1. Review existing related code and understand current structure',
          '2. Implement the core logic changes',
          '3. Add UI state for loading/error/success',
          '4. Write or update tests',
          '5. Update documentation / inline comments if needed',
          '',
          '## Relevant Files',
          '- `bosun/ui/tabs/tasks.js` — task UI components',
          '- `bosun/ui-server.mjs` — API endpoints',
          '- `bosun/ui/modules/` — shared utilities',
          '',
          '## Edge Cases',
          '- Handle API errors gracefully',
          '- Works on both mobile (Telegram WebApp) and desktop',
        ].join('\n');
        addLog('info', 'ai', `Task rewritten: ${origTitle}`);
        return { ok: true, data: { title: origTitle, description: rewrittenDesc } };
      }
      if (route === '/api/tasks/update') {
        const t = findTask(body?.taskId || body?.id);
        if (t) { Object.assign(t, body, { updated: Date.now() }); addLog('info', 'kanban', `Task updated: ${t.title}`); }
        return { ok: true, data: t || null };
      }
      if (route === '/api/tasks/edit') {
        const t = findTask(body?.taskId || body?.id);
        if (t) { if (body?.title) t.title = body.title; if (body?.priority) t.priority = body.priority; t.updated = Date.now(); }
        return { ok: true, data: t || null };
      }
      if (route === '/api/tasks/start') {
        const t = findTask(body?.taskId);
        if (t) { t.status = 'inprogress'; t.updated = Date.now(); addLog('info', 'task-executor', `Task started: ${t.title}`); }
        return { ok: true, data: t || null };
      }
      if (route === '/api/tasks/retry') {
        const t = findTask(body?.taskId);
        if (t) { t.status = 'todo'; t.updated = Date.now(); addLog('info', 'task-executor', `Task retried: ${t.title}`); }
        return { ok: true, data: t || null };
      }
      if (route === '/api/tasks/ignore') {
        const t = findTask(body?.taskId || body?.id);
        if (t) { t.status = 'ignored'; t.updated = Date.now(); addLog('info', 'kanban', `Task ignored: ${t.title}`); }
        return { ok: true, data: t || null };
      }
      if (route === '/api/tasks/unignore') {
        const t = findTask(body?.taskId || body?.id);
        if (t) { t.status = 'todo'; t.updated = Date.now(); addLog('info', 'kanban', `Task unignored: ${t.title}`); }
        return { ok: true, data: t || null };
      }

      // ── Library ──
      if (route === '/api/library') {
        ensureLibrarySeeded();
        const type = (params.get('type') || '').trim();
        const search = (params.get('search') || '').trim().toLowerCase();
        let list = STATE.libraryEntries.slice();
        if (type && type !== 'all') list = list.filter(e => e.type === type);
        if (search) {
          list = list.filter(e => {
            const hay = [e.name, e.description, e.id, ...(e.tags || [])].join(' ').toLowerCase();
            return hay.includes(search);
          });
        }
        return { ok: true, data: list };
      }
      if (route === '/api/library/entry') {
        ensureLibrarySeeded();
        if (method === 'GET') {
          const id = (params.get('id') || '').trim();
          const entry = STATE.libraryEntries.find(e => e.id === id);
          if (!entry) return { ok: false, error: 'not found' };
          return { ok: true, data: { ...entry, content: STATE.libraryContents[id] ?? '' } };
        }
        if (method === 'POST') {
          const payload = body || {};
          const id = payload.id || slugify(payload.name);
          if (!id || !payload.type || !payload.name) return { ok: false, error: 'missing fields' };
          const nowIso = new Date().toISOString();
          const idx = STATE.libraryEntries.findIndex(e => e.id === id);
          const entry = {
            id,
            type: payload.type,
            name: payload.name,
            description: payload.description || '',
            filename: payload.filename || `${id}.${payload.type === 'agent' ? 'json' : 'md'}`,
            tags: Array.isArray(payload.tags) ? payload.tags : [],
            scope: payload.scope || 'global',
            workspace: payload.workspace ?? null,
            createdAt: idx >= 0 ? STATE.libraryEntries[idx].createdAt : nowIso,
            updatedAt: nowIso,
          };
          if (idx >= 0) STATE.libraryEntries[idx] = entry;
          else STATE.libraryEntries.push(entry);
          if (payload.content !== undefined) {
            STATE.libraryContents[id] = payload.content;
          }
          return { ok: true, data: entry };
        }
        if (method === 'DELETE') {
          const id = body?.id;
          if (!id) return { ok: false, error: 'id required' };
          const idx = STATE.libraryEntries.findIndex(e => e.id === id);
          if (idx < 0) return { ok: false, error: 'not found' };
          STATE.libraryEntries.splice(idx, 1);
          delete STATE.libraryContents[id];
          return { ok: true };
        }
      }
      if (route === '/api/library/scopes') {
        return { ok: true, data: [
          { name: 'ui', source: 'folder', count: 0 },
          { name: 'api', source: 'folder', count: 0 },
          { name: 'infra', source: 'folder', count: 0 },
          { name: 'docs', source: 'folder', count: 0 },
        ]};
      }
      if (route === '/api/library/init') {
        const result = ensureLibrarySeeded(true);
        return { ok: true, data: result };
      }
      if (route === '/api/library/rebuild') {
        ensureLibrarySeeded();
        return { ok: true, data: { count: STATE.libraryEntries.length, added: 0, removed: 0 } };
      }
      if (route === '/api/library/match-profile') {
        ensureLibrarySeeded();
        const title = (params.get('title') || '').toLowerCase();
        let best = null;
        let bestScore = 0;
        for (const entry of STATE.libraryEntries) {
          if (entry.type !== 'agent') continue;
          const tags = entry.tags || [];
          let score = 0;
          for (const tag of tags) if (title.includes(tag)) score += 2;
          if (title.includes(entry.id.replace(/-/g, ' '))) score += 3;
          if (score > bestScore) {
            bestScore = score;
            best = { ...entry, score };
          }
        }
        return { ok: true, data: best };
      }

      // ── Agents ──
      if (route === '/api/agents')
        return { data: STATE.agents };
      if (route === '/api/agents/available')
        return { ok: true, data: STATE.availableAgents };
      if (route === '/api/agents/switch') {
        const agentId = body?.agentId || body?.id;
        if (agentId) STATE.activeAgentId = agentId;
        return { ok: true, activeAgent: STATE.activeAgentId };
      }
      if (route === '/api/agents/mode') {
        if (method === 'POST') {
          if (body?.mode) STATE.agentMode = body.mode;
          return { ok: true, mode: STATE.agentMode };
        }
        return { ok: true, mode: STATE.agentMode };
      }
      if (route === '/api/agents/sdk-command') {
        const cmd = body?.command || '';
        addLog('info', 'sdk', `SDK command: ${cmd}`);
        return { ok: true, command: cmd, response: 'SDK command executed in demo mode: ' + cmd };
      }
      if (route === '/api/agents/info') {
        const agent = STATE.availableAgents.find(a => a.id === STATE.activeAgentId) || STATE.availableAgents[0];
        return { ok: true, data: agent };
      }
      // ── Agent Events (dynamic from simulation) ──
      if (route === '/api/agents/events') {
        const taskId = params.get('taskId');
        const type = params.get('type');
        const limit = parseInt(params.get('limit')) || 100;
        // Build events dynamically from current simulation state
        let events = [];
        for (const t of STATE.tasks) {
          const base = { taskId: t.id };
          if (t.status === 'inprogress' || t.status === 'inreview' || t.status === 'done') {
            events.push({ ...base, type: 'agent:task-started', payload: { title: t.title, sdk: t.assignee || 'copilot-claude' }, ts: (t.updated || now) - 120000 });
            events.push({ ...base, type: 'agent:heartbeat', payload: { alive: true }, ts: (t.updated || now) - 30000 });
          }
          if (t.status === 'inreview') {
            events.push({ ...base, type: 'agent:auto-review', payload: { title: t.title, branch: t.branch }, ts: t.updated || now });
          }
          if (t.status === 'done') {
            events.push({ ...base, type: 'agent:task-completed', payload: { title: t.title, success: true, hasCommits: true, branch: t.branch }, ts: t.updated || now });
          }
        }
        // Sort by timestamp
        events.sort((a, b) => a.ts - b.ts);
        if (taskId) events = events.filter(e => e.taskId === taskId);
        if (type) events = events.filter(e => e.type === type);
        events = events.slice(-limit);
        return { ok: true, events };
      }
      if (route === '/api/agents/events/errors') {
        const taskId = params.get('taskId');
        if (taskId) {
          return { ok: true, taskId, errors: [] };
        }
        return { ok: true, patterns: {} };
      }
      if (route === '/api/agents/events/liveness') {
        // Show active simulation tasks as live agents
        const liveAgents = [];
        for (const [tid] of activeSims) {
          liveAgents.push({ taskId: tid, lastHeartbeat: now - 5000, alive: true, staleSinceMs: null });
        }
        return { ok: true, agents: liveAgents };
      }
      if (route === '/api/agents/events/status') {
        return { ok: true, started: true, eventLogSize: liveLogBuffer.length, trackedAgents: activeSims.size, errorTrackedTasks: 0, autoActionTasks: activeSims.size, listenerCount: 0, liveness: [...activeSims.keys()].map(tid => ({
          taskId: tid, lastHeartbeat: now - 5000, alive: true, staleSinceMs: null,
        })), errorPatterns: {} , errorPatterns: {
          build_failure: { count: 3, lastSeen: now - 60000, tasks: ['demo-task-1'] },
        }};
      }
      if (route === '/api/executors')
        return { executors: STATE.executors };

      // ── Logs ──
      if (route === '/api/logs') {
        const lines = parseInt(params.get('lines')) || 50;
        const entries = STATE.logs.slice(0, lines);
        return { data: { lines: entries.map(formatLogLine) }, lines: entries.map(formatLogLine) };
      }
      if (route === '/api/agent-logs')
        return { data: STATE.agentLogFiles };
      if (route === '/api/agent-logs/tail') {
        const file = params.get('file') || params.get('query') || '';
        const n = parseInt(params.get('lines')) || 100;
        // Return real log entries from the live simulation
        const relevantLogs = liveLogBuffer.filter(entry => {
          if (!file) return true;
          const hay = `${entry.source} ${entry.msg}`.toLowerCase();
          return hay.includes(file.toLowerCase()) || entry.source === file;
        }).slice(-n);
        const lines = relevantLogs.length > 0
          ? relevantLogs.map(e => `[${new Date(e.ts).toISOString()}] [${e.level}] ${e.source}: ${e.msg}`)
          : liveLogBuffer.slice(-n).map(e => `[${new Date(e.ts).toISOString()}] [${e.level}] ${e.source}: ${e.msg}`);
        return { data: { lines } };
      }
      if (route === '/api/agent-context') {
        const q = params.get('query') || '';
        return { data: buildContextForQuery(q) };
      }

      // ── Health ──
      if (route === '/api/health')
        return STATE.health;

      // ── Infrastructure ──
      if (route === '/api/infra')
        return { data: STATE.infra };
      if (route === '/api/worktrees') {
        if (route === '/api/worktrees') return { data: STATE.worktrees, stats: { total: STATE.worktrees.length, active: STATE.worktrees.filter(w => w.active).length } };
      }
      if (route === '/api/worktrees/prune') {
        STATE.worktrees = STATE.worktrees.filter(w => w.active); addLog('info', 'worktree', 'Pruned inactive worktrees');
        return { ok: true, pruned: 1 };
      }
      if (route === '/api/worktrees/release') {
        const branch = body?.branch;
        const wt = STATE.worktrees.find(w => w.branch === branch);
        if (wt) wt.active = false;
        return { ok: true };
      }

      // ── Managed Workspaces ──
      if (route === '/api/workspaces')
        return { ok: true, data: STATE.managedWorkspaces, activeId: STATE.activeWorkspaceId };
      if (route === '/api/workspaces/active') {
        if (method === 'POST' && body?.workspaceId) {
          STATE.activeWorkspaceId = body.workspaceId;
          return { ok: true, activeId: body.workspaceId };
        }
        const active = STATE.managedWorkspaces.find(w => w.id === STATE.activeWorkspaceId) || null;
        return { ok: true, data: active };
      }
      if (route === '/api/workspaces/create') {
        const name = body?.name || 'new-workspace';
        const ws = { id: 'ws-' + Math.random().toString(36).slice(2, 7), name, path: '/home/demo/repos/' + name, active: false, repos: [], createdAt: Date.now() };
        STATE.managedWorkspaces.push(ws);
        return { ok: true, data: ws };
      }
      if (route === '/api/workspaces/delete') {
        const wsId = body?.workspaceId || body?.id;
        STATE.managedWorkspaces = STATE.managedWorkspaces.filter(w => w.id !== wsId);
        if (STATE.activeWorkspaceId === wsId) STATE.activeWorkspaceId = STATE.managedWorkspaces[0]?.id || null;
        return { ok: true, deleted: true };
      }
      if (route === '/api/workspaces/pull') {
        const wsId = body?.workspaceId || body?.id;
        const ws = STATE.managedWorkspaces.find(w => w.id === wsId);
        return { ok: true, data: (ws?.repos || []).map(r => ({ repo: r.name, status: 'up-to-date', branch: r.branch })) };
      }
      if (route === '/api/workspaces/repos/add') {
        const ws = STATE.managedWorkspaces.find(w => w.id === body?.workspaceId);
        if (ws) {
          const repo = { name: body?.name || body?.url?.split('/').pop()?.replace('.git','') || 'repo', url: body?.url, branch: body?.branch || 'main', primary: Boolean(body?.primary) };
          ws.repos.push(repo);
          return { ok: true, data: repo };
        }
        return { ok: false, error: 'workspace not found' };
      }
      if (route === '/api/workspaces/repos/remove') {
        const ws = STATE.managedWorkspaces.find(w => w.id === body?.workspaceId);
        if (ws) ws.repos = ws.repos.filter(r => r.name !== (body?.repoName || body?.name));
        return { ok: true, removed: true };
      }
      if (route === '/api/workspaces/scan') {
        return { ok: true, data: STATE.managedWorkspaces, scanned: STATE.managedWorkspaces.length, added: 0, updated: 0 };
      }

      // ── Workflows ──
      if (route === '/api/workflows') {
        return { ok: true, workflows: STATE.workflows.map(w => ({ id: w.id, name: w.name, description: w.description, category: w.category, enabled: w.enabled !== false, nodeCount: w.nodeCount || (w.nodes || []).length, trigger: (w.nodes || [])[0]?.type || 'manual', nodes: w.nodes || [], edges: w.edges || [] })) };
      }
      if (route === '/api/workflows/save') {
        const wf = body || {};
        wf.id = wf.id || 'wf-' + Math.random().toString(36).slice(2, 9);
        wf.metadata = { ...wf.metadata, updatedAt: new Date().toISOString(), createdAt: wf.metadata?.createdAt || new Date().toISOString() };
        wf.nodeCount = (wf.nodes || []).length;
        const idx = STATE.workflows.findIndex(w => w.id === wf.id);
        if (idx >= 0) STATE.workflows[idx] = wf; else STATE.workflows.push(wf);
        return { ok: true, workflow: wf };
      }
      if (route === '/api/workflows/templates') {
        return { ok: true, templates: STATE.workflowTemplates };
      }
      if (route === '/api/workflows/node-types') {
        return { ok: true, nodeTypes: STATE.workflowNodeTypes };
      }
      if (route === '/api/workflows/install-template') {
        const tpl = STATE.workflowTemplates.find(t => t.id === body?.templateId);
        if (!tpl) return { ok: false, error: 'Template not found' };
        // Deep-clone nodes/edges from matching demo workflow or generate from template
        const donor = STATE.workflows.find(w => w.name === tpl.name);
        const wf = { id: 'wf-' + Math.random().toString(36).slice(2, 9), name: tpl.name, description: tpl.description, category: tpl.category, enabled: true, nodeCount: tpl.nodeCount, trigger: 'trigger.pr_event', nodes: JSON.parse(JSON.stringify(donor?.nodes || tpl.nodes || [])), edges: JSON.parse(JSON.stringify(donor?.edges || tpl.edges || [])), variables: body?.overrides || {}, metadata: { installedFrom: tpl.id, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() } };
        STATE.workflows.push(wf);
        return { ok: true, workflow: wf };
      }
      if (route === '/api/workflows/runs') {
        return {
          ok: true,
          runs: STATE.workflowRuns.map((run) => {
            const wf = STATE.workflows.find((item) => item.id === run.workflowId);
            return {
              ...run,
              workflowName: run.workflowName || wf?.name || run.workflowId,
            };
          }),
        };
      }
      if (route.startsWith('/api/workflows/runs/')) {
        const runId = decodeURIComponent(route.replace('/api/workflows/runs/', '')).trim();
        const run = STATE.workflowRuns.find((item) => item.runId === runId);
        if (!run) return { ok: false, error: 'Workflow run not found' };

        const wf = STATE.workflows.find((item) => item.id === run.workflowId);
        const startedAtMs = Date.parse(run.startedAt || '') || Date.now();
        const duration = Number.isFinite(Number(run.duration)) ? Number(run.duration) : 0;
        const endedAt = run.endedAt || new Date(startedAtMs + duration).toISOString();
        const nodeCount = Math.max(1, Number(run.nodeCount) || 1);
        const nodeStatuses = {};
        const nodeOutputs = {};
        for (let i = 1; i <= nodeCount; i += 1) {
          const nodeId = 'node-' + String(i).padStart(2, '0');
          const isFailingNode = run.status === 'failed' && i === nodeCount;
          nodeStatuses[nodeId] = isFailingNode ? 'failed' : 'completed';
          nodeOutputs[nodeId] = {
            message: isFailingNode ? 'Demo failure output' : 'Demo node output',
            index: i,
            runId,
            workflowId: run.workflowId,
          };
        }

        const errors = run.status === 'failed'
          ? [{ nodeId: 'node-' + String(nodeCount).padStart(2, '0'), message: 'Demo workflow step failed' }]
          : [];

        return {
          ok: true,
          run: {
            ...run,
            workflowName: run.workflowName || wf?.name || run.workflowId,
            endedAt,
            detail: {
              nodeStatuses,
              nodeOutputs,
              logs: [
                'Run ' + runId + ' started',
                'Workflow ' + (wf?.name || run.workflowId) + ' processed ' + nodeCount + ' nodes',
                run.status === 'failed' ? 'Run failed in demo mode' : 'Run completed in demo mode',
              ],
              errors,
            },
          },
        };
      }
      if (route.startsWith('/api/workflows/') && !route.includes('/save') && !route.includes('/templates') && !route.includes('/install') && !route.includes('/node-types') && !route.includes('/runs')) {
        const segs = route.replace('/api/workflows/', '').split('/');
        const wfId = segs[0];
        const action = segs[1] || '';
        if (action === 'execute') {
          const run = { runId: 'run-' + Math.random().toString(36).slice(2, 6), workflowId: wfId, status: 'completed', nodeCount: 6, duration: 30000 + Math.floor(Math.random() * 30000), errorCount: 0, startedAt: new Date().toISOString() };
          STATE.workflowRuns.unshift(run);
          return { ok: true, result: run };
        }
        if (action === 'runs') {
          return { ok: true, runs: STATE.workflowRuns.filter(r => r.workflowId === wfId) };
        }
        if (method === 'DELETE') {
          STATE.workflows = STATE.workflows.filter(w => w.id !== wfId);
          return { ok: true };
        }
        const wf = STATE.workflows.find(w => w.id === wfId);
        return wf ? { ok: true, workflow: wf } : { ok: false, error: 'Workflow not found' };
      }

      // ── Shared Workspaces ──
      if (route === '/api/shared-workspaces')
        return { data: STATE.sharedWorkspaces };
      if (route === '/api/shared-workspaces/claim') {
        const ws = { id: 'sw-' + Math.random().toString(36).slice(2, 5), name: body?.name || 'workspace', claimedBy: body?.agent || 'demo', claimedAt: Date.now(), expiresAt: Date.now() + 2*hr };
        STATE.sharedWorkspaces.push(ws);
        return { ok: true, data: ws };
      }
      if (route === '/api/shared-workspaces/renew') {
        const ws = STATE.sharedWorkspaces.find(w => w.id === body?.id);
        if (ws) ws.expiresAt = Date.now() + 2*hr;
        return { ok: true };
      }
      if (route === '/api/shared-workspaces/release') {
        STATE.sharedWorkspaces = STATE.sharedWorkspaces.filter(w => w.id !== body?.id);
        return { ok: true };
      }

      // ── Git ──
      if (route === '/api/git/branches')
        return { data: STATE.gitBranches };
      if (route === '/api/git/diff')
        return { data: STATE.gitDiff };
      if (route === '/api/recent-commits')
        return {
          ok: true,
          data: [
            { hash: 'f464d9a', message: 'fix(ui): stretch chat to bottom, remove bot-fab, fix Bot Controls', author: 'bosun-agent', date: new Date(Date.now() - 1 * hr).toISOString() },
            { hash: 'e39aa3c', message: 'feat(ui): VS Code-style collapsible sidebar and session rail', author: 'bosun-agent', date: new Date(Date.now() - 4 * hr).toISOString() },
            { hash: 'c2d8f7b', message: 'fix(api): stabilize shared state sync retries', author: 'bosun-agent', date: new Date(Date.now() - 8 * hr).toISOString() },
          ],
        };

      // ── Sessions ──
      if (route === '/api/sessions' && method === 'GET') {
        const typeFilter = String(params.get('type') || '').toLowerCase();
        let sessions = STATE.sessions;
        if (typeFilter) {
          if (typeFilter === 'primary') {
            sessions = sessions.filter((s) => {
              const t = String(s.type || '').toLowerCase();
              return t !== 'task' && t !== 'review';
            });
          } else {
            sessions = sessions.filter((s) => String(s.type || '').toLowerCase() === typeFilter);
          }
        }
        return {
          sessions: sessions.map((s) => ({
            id: s.id,
            title: s.title,
            type: s.type,
            status: s.status,
            taskId: s.taskId,
            branch: s.branch,
            createdAt: s.createdAt,
            updatedAt: s.updatedAt,
            lastMessage: s.lastMessage,
          })),
        };
      }
      if (route.match(/^\/api\/sessions\/[^/]+\/diff$/)) {
        const sid = route.split('/')[3];
        return { diff: STATE.sessionDiffs[sid] || { files: [] } };
      }
      if (route.match(/^\/api\/sessions\/[^/]+\/message$/)) {
        const sid = route.split('/')[3];
        const ses = STATE.sessions.find(s => s.id === sid);
        const content = String(body?.content || body?.text || body?.message || '');
        const attachments = Array.isArray(body?.attachments) ? body.attachments : [];
        const mode = body?.mode;
        if (ses && mode) ses.metadata = { ...(ses.metadata || {}), mode };
        if (ses && (content || attachments.length)) {
          appendMessage(ses, makeMsg('user', content, Date.now(), null, attachments));
          ses.status = ses.status === 'archived' ? 'active' : ses.status;
          scheduleResponses(ses, mode);
        }
        return { ok: true, session: ses || null };
      }
      if (route.match(/^\/api\/sessions\/[^/]+\/attachments$/) && method === 'POST') {
        const attachments = [];
        const files = Array.isArray(body?.files) ? body.files : [];
        if (files.length) {
          for (const file of files) {
            attachments.push(makeAttachment(file.name, file.type?.startsWith('image/') ? 'image' : 'file', file.type, file.size));
          }
        } else {
          attachments.push(makeAttachment());
        }
        return { ok: true, attachments };
      }
      if (route.match(/^\/api\/sessions\/[^/]+\/resume$/)) {
        const sid = route.split('/')[3];
        const ses = STATE.sessions.find(s => s.id === sid);
        if (ses) ses.status = 'active';
        return { ok: true, session: ses || null };
      }
      if (route.match(/^\/api\/sessions\/[^/]+\/archive$/)) {
        const sid = route.split('/')[3];
        const ses = STATE.sessions.find(s => s.id === sid);
        if (ses) ses.status = 'archived';
        return { ok: true, session: ses || null };
      }
      if (route === '/api/sessions/create') {
        const id = 'ses-' + Math.random().toString(36).slice(2, 6);
        const s = {
          id,
          title: body?.title || 'New Session',
          type: body?.type || 'manual',
          metadata: { mode: body?.mode || 'agent' },
          status: 'active',
          taskId: body?.taskId || null,
          branch: body?.branch || null,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          lastMessage: 'Session created.',
          messages: [
            makeMsg('system', 'Session initialized in demo mode.', Date.now(), 'system'),
          ],
        };
        STATE.sessions.unshift(s);
        STATE.sessionDiffs[id] = { files: [] };
        return { ok: true, session: s };
      }
      if (route.match(/^\/api\/sessions\/[^/]+$/) && method === 'GET') {
        const sid = route.split('/')[3];
        const ses = STATE.sessions.find(s => s.id === sid) || null;
        return { session: ses };
      }

      // ── Settings & Config ──
      if (route === '/api/settings') {
        return {
          ok: true,
          data: { ...STATE.settings },
          meta: {
            envPath: '.env',
            configPath: 'bosun.config.json',
            configDir: '/demo',
          },
        };
      }
      if (route === '/api/settings/update') {
        const changes = (body && typeof body === 'object' && body.changes && typeof body.changes === 'object')
          ? body.changes
          : {};
        const keys = Object.keys(changes);
        Object.assign(STATE.settings, changes);
        return {
          ok: true,
          data: { ...STATE.settings },
          updatedConfig: keys,
          configSync: {
            total: keys.length,
            updated: keys.length,
            skipped: [],
            configPath: 'bosun.config.json',
          },
        };
      }
      if (route === '/api/config/update') {
        const updates = body && typeof body === 'object' ? body : {};
        Object.assign(STATE.settings, updates);
        return { ok: true, data: { ...STATE.settings } };
      }

      // ── Command ──
      if (route === '/api/command') {
        const cmd = body?.command || '';
        addLog('info', 'command', `Executed: ${cmd}`);
        return { ok: true, command: cmd, response: 'Command executed in demo mode: ' + cmd };
      }

      // ── Presence ──
      if (route === '/api/presence')
        return { data: STATE.presence };

      // ── Project ──
      if (route === '/api/project' || route === '/api/project-summary')
        return { data: buildProjectSnapshot() };

      // ── Supervisor ──
      if (route === '/api/supervisor/status')
        return {
          systemHealth: { started: true, trackedTasks: STATE.tasks.filter(t => t.status === 'inprogress').length, averageHealth: 85, blockedTasks: 0, activeInterventions: 0 },
          tasks: STATE.tasks.filter(t => t.status === 'inprogress').map(t => ({
            taskId: t.id, interventionCount: 0, lastDecision: null,
            averageHealthScore: 85, currentHealthScore: 85,
            qualityScore: null, reviewVerdict: null, reviewIssueCount: 0,
            recentSituations: [{ situation: 'healthy', ts: Date.now() }],
          })),
        };
      if (route.match(/^\/api\/supervisor\/task\/[^/]+$/))
        return {
          taskId: route.split('/')[4],
          interventionCount: 0, lastDecision: null,
          averageHealthScore: 85, currentHealthScore: 85,
          qualityScore: null, reviewVerdict: null, reviewIssueCount: 0,
          recentSituations: [{ situation: 'healthy', ts: Date.now() }],
        };

      // ── Catch-all: return empty success for any unhandled /api/ route ──
      console.debug('[demo] Unhandled API route:', method, path);
      return { ok: true, data: null };
    }

    /* ── Intercept fetch() — ALL /api/ calls handled internally ───── */
    const _realFetch = window.fetch;
    window.fetch = function(url, options) {
      const path = typeof url === 'string' ? url : url?.url || '';

      // Intercept ALL /api/ calls — nothing reaches the network
      if (path.startsWith('/api/') || path.startsWith('/api?')) {
        let body = null;
        if (options?.body) {
          if (options.body instanceof FormData) {
            body = {};
            const files = [];
            for (const [key, value] of options.body.entries()) {
              if (value instanceof File) {
                files.push({ name: value.name, size: value.size, type: value.type });
              } else {
                body[key] = value;
              }
            }
            if (files.length) body.files = files;
          } else {
            try { body = JSON.parse(options.body); } catch {}
          }
        }
        const method = (options?.method || 'GET').toUpperCase();
        return Promise.resolve(handleApi(path, method, body)).then(data => new Response(JSON.stringify(data), {
          status: 200,
          headers: { 'Content-Type': 'application/json' },
        }));
      }

      // Pass through non-API requests (fonts, CDN, ES modules, etc.)
      return _realFetch.apply(this, arguments);
    };

    /* ── Intercept WebSocket ───────────────────────────────────────── */
    const _RealWS = window.WebSocket;
    window.WebSocket = function(url, protocols) {
      const fake = {
        url: url,
        readyState: 1, // OPEN
        bufferedAmount: 0,
        extensions: '',
        protocol: '',
        onopen: null,
        onmessage: null,
        onclose: null,
        onerror: null,
        send(data) { /* swallow */ },
        close() {
          this.readyState = 3;
          if (this.onclose) this.onclose({ code: 1000, reason: 'Demo mode' });
        },
        addEventListener(type, handler) {
          this['on' + type] = handler;
        },
        removeEventListener() {},
      };

      // Simulate open after microtask + register as live WS
      setTimeout(() => {
        fake.readyState = 1;
        _demoWS = fake; // Register for simulation engine to push events
        if (fake.onopen) fake.onopen({});

        // Send pong responses
        setInterval(() => {
          if (fake.onmessage) {
            fake.onmessage({ data: JSON.stringify({ type: 'pong', ts: Date.now() }) });
          }
        }, 5000);
      }, 100);

      return fake;
    };
    window.WebSocket.CONNECTING = 0;
    window.WebSocket.OPEN = 1;
    window.WebSocket.CLOSING = 2;
    window.WebSocket.CLOSED = 3;

  })();
  </script>
</head>
<body>
  <!-- Demo mode banner -->
  <div class="demo-banner">:zap: Bosun Demo Mode — Seed Data</div>

  <!-- ═══ Telegram MiniApp (single view — loads immediately) ═══════════ -->
  <div class="demo-container">
    <!-- MiniApp content (wraps #app) -->
    <div class="miniapp-content">
      <div id="app">
        <div id="boot-loader" style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;font-family:'Inter',sans-serif;color:#9aa3b8;background:#0b0f14;overflow:hidden">
          <style>
            .boot-ring{position:absolute;inset:0;border-radius:50%;border:2px solid rgba(76,201,240,.15);animation:boot-spin 3s linear infinite}
            .boot-ring-inner{position:absolute;inset:8px;border-radius:50%;border:2px solid transparent;border-top-color:#4cc9f0;border-right-color:rgba(76,201,240,.4);animation:boot-spin 1.5s linear infinite reverse}
            .boot-dot{position:absolute;top:50%;left:50%;width:16px;height:16px;margin:-8px 0 0 -8px;border-radius:50%;background:linear-gradient(135deg,#4cc9f0,#60cc5d);box-shadow:0 0 20px rgba(76,201,240,.5);animation:boot-pulse 2s ease-in-out infinite}
            @keyframes boot-spin{to{transform:rotate(360deg)}}
            @keyframes boot-pulse{0%,100%{transform:scale(1);opacity:.8}50%{transform:scale(1.2);opacity:1}}
          </style>
          <div style="position:relative;width:60px;height:60px;margin-bottom:16px">
            <div class="boot-ring"></div>
            <div class="boot-ring-inner"></div>
            <div class="boot-dot"></div>
          </div>
          <div style="font-size:13px;color:#64748b">Loading Telegram MiniApp...</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bot Menu Panel (multi-layer navigation) -->
  <div class="bot-panel" id="bot-panel">
    <div class="bot-panel-header">
      <button class="bot-panel-back" id="bot-panel-back" title="Back">←</button>
      <div class="bot-panel-title" id="bot-panel-title">Bosun Control Center</div>
      <button class="bot-panel-home" id="bot-panel-home" title="Home" aria-label="Home"></button>
      <button class="bot-panel-close" id="bot-panel-close" title="Close" aria-label="Close"></button>
    </div>
    <div class="bot-panel-body" id="bot-panel-body"></div>
    <div class="bot-panel-result" id="bot-panel-result"></div>
    <div class="bot-panel-keyboard" id="bot-panel-keyboard"></div>
  </div>

  <!-- Load the real app.js immediately -->
  <script type="module" src="app.js"></script>

  <!-- ═══ BOT MENU ENGINE (multi-layer screen navigation) ═══════════ -->
  <script type="module">
  import { render } from "preact";
  import { resolveIcon } from "./modules/icon-utils.js";

  (function() {
    'use strict';

    const fab       = document.getElementById('bot-fab');
    const panel     = document.getElementById('bot-panel');
    const backBtn   = document.getElementById('bot-panel-back');
    const homeBtn   = document.getElementById('bot-panel-home');
    const closeBtn  = document.getElementById('bot-panel-close');
    const titleEl   = document.getElementById('bot-panel-title');
    const bodyEl    = document.getElementById('bot-panel-body');
    const resultEl  = document.getElementById('bot-panel-result');
    const kbEl      = document.getElementById('bot-panel-keyboard');

    const iconCache = new Map();

    function iconMarkup(iconKey) {
      if (iconCache.has(iconKey)) return iconCache.get(iconKey);
      const vnode = resolveIcon(iconKey);
      if (!vnode) return "";
      const temp = document.createElement("span");
      render(vnode, temp);
      const html = temp.innerHTML;
      temp.replaceChildren();
      iconCache.set(iconKey, html);
      return html;
    }

    function buildIconFragment(text) {
      const str = String(text ?? "");
      let buffer = "";
      let hasIcon = false;
      const frag = document.createDocumentFragment();
      for (const ch of str) {
        if (ch === "\uFE0E" || ch === "\uFE0F") continue;
        const icon = iconMarkup(ch);
        if (icon) {
          if (buffer) {
            frag.appendChild(document.createTextNode(buffer));
            buffer = "";
          }
          const span = document.createElement("span");
          span.className = "icon-inline";
          span.innerHTML = icon;
          frag.appendChild(span);
          hasIcon = true;
        } else {
          buffer += ch;
        }
      }
      if (buffer) frag.appendChild(document.createTextNode(buffer));
      return hasIcon ? frag : null;
    }

    function setIconText(el, text) {
      if (!el) return;
      const frag = buildIconFragment(text);
      if (!frag) {
        el.textContent = text ?? "";
        return;
      }
      el.textContent = "";
      el.appendChild(frag);
    }

    function iconizeHtml(html) {
      const container = document.createElement("div");
      container.innerHTML = html || "";
      const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null);
      const nodes = [];
      while (walker.nextNode()) nodes.push(walker.currentNode);
      nodes.forEach((node) => {
        const frag = buildIconFragment(node.nodeValue);
        if (frag) node.replaceWith(frag);
      });
      return container.innerHTML;
    }

    homeBtn.innerHTML = `<span class="icon-inline">${iconMarkup("home")}</span>`;
    closeBtn.innerHTML = `<span class="icon-inline">${iconMarkup("close")}</span>`;

    let panelOpen = false;
    let currentScreen = 'home';
    const navStack = [];

    // ── Expose seed data references ──
    const TASKS    = window.SEED_TASKS    || [];
    const AGENTS   = window.SEED_AGENTS   || [];
    const LOGS     = window.SEED_LOGS     || [];
    const SESSIONS = window.SEED_SESSIONS || [];
    const INFRA    = window.SEED_INFRA    || {};

    // ══════════════════════════════════════════════════════════════════
    //  MULTI-LAYER SCREEN DEFINITIONS
    //  Mirrors the real telegram-bot.mjs UI_SCREENS hierarchy
    // ══════════════════════════════════════════════════════════════════

    const SCREENS = {
      // ─── HOME ───
      home: {
        title: ':sliders: Bosun Control Center',
        body: 'Choose a section to manage your automation fleet.',
        keyboard: [
          [{ text: ':chart: Overview', go: 'overview' }, { text: ':compass: Tasks', go: 'tasks' }, { text: ':bot: Agents', go: 'agents' }],
          [{ text: ':settings: Executor', go: 'executor' }, { text: ':server: Routing', go: 'routing' }, { text: ':git: Workspaces', go: 'workspaces' }],
          [{ text: ':folder: Logs & Git', go: 'logs_menu' }, { text: ':plug: Integrations', go: 'integrations' }],
          [{ text: ':refresh: Refresh', cmd: 'status' }, { text: ':close: Close', action: 'close' }],
        ],
      },

      // ─── OVERVIEW (sub-menu) ───
      overview: {
        title: ':chart: Overview',
        parent: 'home',
        body: 'Live status, health, and presence dashboards.',
        keyboard: [
          [{ text: ':chart: Status', cmd: 'status' }, { text: ':clipboard: Tasks', cmd: 'tasks' }, { text: ':bot: Agents', cmd: 'agents' }],
          [{ text: ':heart: Health', cmd: 'health' }, { text: ':alert: Anomalies', cmd: 'anomalies' }, { text: ':eye: Presence', cmd: 'presence' }],
          [{ text: ':edit: Logs', cmd: 'logs' }, { text: ':chart: Metrics', cmd: 'metrics' }],
        ],
      },

      // ─── TASKS (sub-menu with deeper levels) ───
      tasks: {
        title: ':compass: Task Operations',
        parent: 'home',
        body: 'Pause/resume, plan, retry, cleanup, and guided starts.',
        keyboard: [
          [{ text: ':pause: Pause', cmd: 'pause' }, { text: ':play: Resume', cmd: 'resume' }, { text: ':refresh: Restart', cmd: 'restart' }],
          [{ text: ':clipboard: List Tasks', cmd: 'tasks' }, { text: ':trash: Cleanup', cmd: 'cleanup' }, { text: ':chart: Status', cmd: 'status' }],
          [{ text: ':grid: Planner', go: 'planner' }, { text: ':repeat: Retry', go: 'retry' }, { text: ':settings: Executor', go: 'executor' }],
          [{ text: ':folder: Task Lists', go: 'task_lists' }, { text: ':play: Start Task', cmd: 'starttask' }],
        ],
      },
      task_lists: {
        title: ':folder: Task Lists',
        parent: 'tasks',
        body: 'Browse tasks by kanban status.',
        keyboard: [
          [{ text: ':download: Backlog', cmd: 'tasks_backlog' }, { text: ':edit: Draft', cmd: 'tasks_draft' }],
          [{ text: ':check: Todo', cmd: 'tasks_todo' }, { text: ':alert: Active', cmd: 'tasks_active' }],
          [{ text: ':search: Review', cmd: 'tasks_review' }, { text: ':ban: Blocked', cmd: 'tasks_blocked' }],
          [{ text: ':flag: Done', cmd: 'tasks_done' }],
        ],
      },
      planner: {
        title: ':grid: Task Planner',
        parent: 'tasks',
        body: 'Trigger the planner to seed new tasks from the backlog.',
        keyboard: [
          [{ text: 'Plan 3', cmd: 'plan3' }, { text: 'Plan 5', cmd: 'plan5' }, { text: 'Plan 10', cmd: 'plan10' }],
        ],
      },
      retry: {
        title: ':repeat: Fresh Retry',
        parent: 'tasks',
        body: 'Start a fresh session retry for the active task.',
        keyboard: [
          [{ text: 'Manual', cmd: 'retry_manual' }, { text: 'Stuck', cmd: 'retry_stuck' }, { text: 'Rate Limit', cmd: 'retry_ratelimit' }],
        ],
      },

      // ─── AGENTS (sub-menu with deeper levels) ───
      agents: {
        title: ':bot: Agents',
        parent: 'home',
        body: 'Monitor and steer running agents.',
        keyboard: [
          [{ text: ':bot: Agents', cmd: 'agents' }, { text: ':clipboard: Tasks', cmd: 'tasks' }, { text: ':chart: Status', cmd: 'status' }],
          [{ text: ':folder: Agent Logs', go: 'agent_logs' }, { text: ':link: Threads', go: 'threads' }, { text: ':cpu: History', cmd: 'history' }],
          [{ text: ':compass: Steer', cmd: 'steer' }, { text: ':close: Stop', cmd: 'stop' }, { text: ':server: Background', go: 'background' }],
        ],
      },
      agent_logs: {
        title: ':folder: Agent Logs',
        parent: 'agents',
        body: 'View logs from specific worktree agent sessions.',
        keyboard: [
          [{ text: 've/44-escrow-batch', cmd: 'agentlogs_escrow' }, { text: 've/45-hpc-gpu', cmd: 'agentlogs_hpc' }],
          [{ text: 've/46-docs-guide', cmd: 'agentlogs_docs' }],
        ],
      },
      threads: {
        title: ':link: Threads',
        parent: 'agents',
        body: 'Manage persistent agent threads.',
        keyboard: [
          [{ text: 'List Threads', cmd: 'threads' }, { text: 'Clear Registry', cmd: 'threads_clear' }],
          [{ text: 'Kill Thread', go: 'threads_kill' }],
        ],
      },
      threads_kill: {
        title: ':trash: Kill Thread',
        parent: 'threads',
        body: 'Select a thread to invalidate.',
        keyboard: [
          [{ text: 've/44-escrow-batch', cmd: 'kill_thread_44' }, { text: 've/45-hpc-gpu', cmd: 'kill_thread_45' }],
        ],
      },
      background: {
        title: ':server: Background Mode',
        parent: 'agents',
        body: 'Run tasks silently or background the active agent.',
        keyboard: [
          [{ text: 'Background Active', cmd: 'background_active' }, { text: 'New Background Task', cmd: 'background_new' }],
          [{ text: ':compass: Steer', cmd: 'steer' }, { text: ':close: Stop', cmd: 'stop' }],
        ],
      },

      // ─── EXECUTOR (sub-menu) ───
      executor: {
        title: ':settings: Executor',
        parent: 'home',
        body: 'Executor status, slots, and tuning.',
        keyboard: [
          [{ text: 'Status', cmd: 'executor' }, { text: 'Slots', cmd: 'executor_slots' }, { text: 'Mode', cmd: 'executor_mode' }],
          [{ text: ':chart: Max Parallel', go: 'maxparallel' }, { text: ':pause: Pause', cmd: 'pause' }, { text: ':play: Resume', cmd: 'resume' }],
        ],
      },
      maxparallel: {
        title: ':chart: Max Parallel',
        parent: 'executor',
        body: 'Set the max concurrent task slots.',
        keyboard: [
          [{ text: '0 (Pause)', cmd: 'mp_0' }, { text: '1', cmd: 'mp_1' }, { text: '2', cmd: 'mp_2' }],
          [{ text: '3', cmd: 'mp_3' }, { text: '4', cmd: 'mp_4' }, { text: '6', cmd: 'mp_6' }],
          [{ text: '8', cmd: 'mp_8' }, { text: '12', cmd: 'mp_12' }, { text: '16', cmd: 'mp_16' }],
        ],
      },

      // ─── ROUTING (sub-menu with deeper levels) ───
      routing: {
        title: ':server: Routing & Models',
        parent: 'home',
        body: 'Control model routing, SDKs, and workspace routing.',
        keyboard: [
          [{ text: ':bot: Model', go: 'model' }, { text: ':box: SDK', go: 'sdk' }, { text: ':clipboard: Kanban', cmd: 'kanban' }],
          [{ text: ':globe: Region', go: 'region' }, { text: ':repeat: Auto Backlog', cmd: 'autobacklog' }, { text: ':ruler: Requirements', cmd: 'requirements' }],
          [{ text: ':target: Route Task', cmd: 'route_task' }, { text: ':heart: Health', cmd: 'health' }],
        ],
      },
      model: {
        title: ':bot: Model Override',
        parent: 'routing',
        body: 'Override the executor model for the next run.',
        keyboard: [
          [{ text: 'claude-opus-4-6', cmd: 'model_opus' }, { text: 'o4-mini', cmd: 'model_o4' }],
          [{ text: 'gpt-5.2-codex', cmd: 'model_gpt5' }, { text: 'Default', cmd: 'model_default' }],
        ],
      },
      sdk: {
        title: ':box: SDK Selection',
        parent: 'routing',
        body: 'Choose which SDK backend to use.',
        keyboard: [
          [{ text: 'Copilot', cmd: 'sdk_copilot' }, { text: 'Codex', cmd: 'sdk_codex' }],
          [{ text: 'Auto (default)', cmd: 'sdk_auto' }],
        ],
      },
      region: {
        title: ':globe: Region',
        parent: 'routing',
        body: 'Set the execution region for Codex.',
        keyboard: [
          [{ text: '🇺🇸 US East', cmd: 'region_us' }, { text: '🇸🇪 EU North', cmd: 'region_eu' }],
          [{ text: ':globe: Auto (default)', cmd: 'region_auto' }],
        ],
      },

      // ─── WORKSPACES ───
      workspaces: {
        title: ':git: Workspaces',
        parent: 'home',
        body: 'Manage git worktrees and workspaces.',
        keyboard: [
          [{ text: ':git: Worktrees', cmd: 'worktrees' }, { text: ':git: Branches', cmd: 'branches' }],
          [{ text: ':edit: Git Diff', cmd: 'diff' }, { text: ':file: Git Log', cmd: 'git_log' }],
          [{ text: ':trash: Cleanup', cmd: 'cleanup' }],
        ],
      },

      // ─── LOGS & GIT ───
      logs_menu: {
        title: ':folder: Logs & Git',
        parent: 'home',
        body: 'System logs, agent logs, and git operations.',
        keyboard: [
          [{ text: ':file: Recent Logs', cmd: 'logs' }, { text: ':folder: Agent Logs', go: 'agent_logs' }],
          [{ text: ':edit: Git Diff', cmd: 'diff' }, { text: ':file: Git Log', cmd: 'git_log' }],
          [{ text: ':monitor: Shell', cmd: 'shell' }],
        ],
      },

      // ─── INTEGRATIONS ───
      integrations: {
        title: ':plug: Integrations',
        parent: 'home',
        body: 'Connected services and configuration.',
        keyboard: [
          [{ text: ':git: GitHub', cmd: 'integration_github' }, { text: ':phone: Telegram', cmd: 'integration_telegram' }],
          [{ text: ':monitor: VS Code', cmd: 'integration_vscode' }, { text: ':phone: WhatsApp', cmd: 'integration_whatsapp' }],
          [{ text: ':box: Container', cmd: 'container' }, { text: ':settings: SDK Status', cmd: 'sdk_status' }],
        ],
      },
    };

    // ══════════════════════════════════════════════════════════════════
    //  COMMAND RESPONSE GENERATORS
    // ══════════════════════════════════════════════════════════════════

    const CMDS = {
      status: () => `<strong>:chart: Fleet Status</strong> — <code>● RUNNING</code><br/><br/>`+
        `:clock: Uptime: <code>6d 14h 22m</code><br/>`+
        `:settings: Mode: <code>internal</code><br/>`+
        `:zap: Max Parallel: <code>6</code><br/>`+
        `:folder: Repos: <code>bosun</code> + <code>virtengine</code><br/><br/>`+
        `<strong>This Week</strong><br/>`+
        `:check: Completed: <strong>27</strong> · :git: PRs merged: <strong>22</strong> · :close: Failures: <strong>2</strong> (auto-retried)<br/><br/>`+
        `<strong>Executors</strong><br/>`+
        `├─ <code>copilot-claude</code> :dot: load: 67% tasks: 16<br/>`+
        `└─ <code>codex-default</code> :dot: load: 42% tasks: 11`,

      tasks: () => {
        if (!TASKS.length) return '<strong>:clipboard: Tasks</strong><br/>No tasks found.';
        const icons = { running: ':dot:', queued: ':clock:', done: ':check:', failed: ':close:', cancelled: ':dot:' };
        return '<strong>:clipboard: Active Tasks</strong><br/><br/>' +
          TASKS.map(t => `${icons[t.status]||'·'} <strong>${t.title}</strong> — <code>${t.status}</code>`).join('<br/>');
      },

      agents: () => {
        if (!AGENTS.length) return '<strong>:bot: Agents</strong><br/>No agents configured.';
        return '<strong>:bot: Agent Pool</strong><br/><br/>' +
          AGENTS.map(a => {
            const s = a.healthy === false ? ':dot:' : ':dot:';
            return `${s} <strong>${a.name}</strong> — ${a.provider||'?'} · <code>${a.model||'?'}</code>`;
          }).join('<br/>');
      },

      health: () => `<strong>:heart: System Health</strong> — All Clear<br/><br/>`+
        `:check: GitHub API <code>142ms</code><br/>`+
        `:check: Telegram Bot <code>89ms</code><br/>`+
        `:check: Codex SDK <code>234ms</code><br/>`+
        `:check: Copilot SDK <code>178ms</code><br/>`+
        `:check: Shared State <code>12ms</code><br/>`+
        `:check: Worktree Manager <code>45ms</code>`,

      anomalies: () => `<strong>:search: Anomaly Detector</strong> — <code>All Clear</code><br/><br/>`+
        `:check: No stuck agents<br/>:check: No repeated lint failures<br/>:check: No push loop detected<br/>:check: No memory pressure<br/><br/>`+
        `Streak: <code>14</code> clean checks<br/>Last anomaly: <em>none today</em>`,

      presence: () => `<strong>:users: Agent Presence</strong><br/><br/>`+
        `:dot: <strong>workstation-1</strong> (this machine)<br/>`+
        `   ├─ copilot-claude: busy (#44)<br/>`+
        `   └─ codex-default: busy (#45)<br/><br/>`+
        `Fleet: 1 workstation, 2 agents online`,

      metrics: () => `<strong>:chart: Fleet Metrics</strong> (24h)<br/><br/>`+
        `<strong>Tasks</strong><br/>▓▓▓▓▓▓▓▓▓▓░░ 89% — 47 completed<br/>▓░░░░░░░░░░░  6% — 3 failed<br/><br/>`+
        `<strong>PRs</strong><br/>Created: 52 | Merged: 44 | CI failures: 8 (auto-fixed: 6)`,

      logs: () => {
        if (!LOGS.length) return '<strong>:file: Logs</strong><br/>No recent logs.';
        let html = '<strong>:file: Recent Logs</strong><br/><br/><pre>';
        LOGS.slice(-8).forEach(l => {
          html += `[${(l.level||'info').toUpperCase().padEnd(5)}] ${(l.source||'?').padEnd(10)} ${l.msg}\n`;
        });
        return html + '</pre>';
      },

      executor: () => `<strong>:settings: Executor Pool</strong><br/><br/>`+
        `Mode: <code>internal</code><br/>Max parallel: <code>6</code><br/><br/>`+
        `1. copilot-claude (50%) — COPILOT:CLAUDE_OPUS_4_6<br/>`+
        `2. codex-default (50%) — CODEX:DEFAULT`,

      executor_slots: () => `<strong>:settings: Executor Slots</strong><br/><br/>Active: <strong>2</strong> / 6<br/>Queued: <strong>3</strong><br/>Free: <strong>4</strong>`,
      executor_mode: () => `<strong>:settings: Mode:</strong> <code>internal</code><br/><br/>Available: internal, container, remote`,

      worktrees: () => {
        const wt = INFRA.worktrees || [];
        if (!wt.length) return '<strong>:git: Worktrees</strong><br/>No worktrees found.';
        return '<strong>:git: Git Worktrees</strong><br/><br/>' +
          wt.map(w => `:folder: <strong>${w.branch||w.path}</strong> — ${w.path}`).join('<br/>') +
          `<br/><br/>Total: ${wt.length} worktrees`;
      },

      branches: () => `<strong>:git: Active Branches</strong><br/><br/>`+
        `<strong>virtengine/bosun</strong><br/>`+
        `├─ <code>docs/bosun-improvement-plan</code> :dot: active (PR #17)<br/>`+
        `├─ <code>bs/12-error-correlation</code> :dot: active<br/>`+
        `├─ <code>bs/11-agent-logging-enrich</code> :dot: active<br/>`+
        `├─ <code>fix/kanban-repo-filters</code> :dot: active<br/>`+
        `└─ <code>bs/13-weekly-report</code> :clock: draft<br/><br/>`+
        `<strong>virtengine/virtengine</strong><br/>`+
        `├─ <code>ve/760-market-order-expiry</code> :dot: active<br/>`+
        `├─ <code>ve/761-escrow-batch</code> :dot: active<br/>`+
        `├─ <code>ve/762-veid-token-fix</code> :edit: in review<br/>`+
        `└─ <code>ve/751-security-bulk-remediation</code> (merged, PR #751)`,

      diff: () => `<strong>:edit: Git Diff Summary</strong> (staged)<br/><br/>`+
        `<code>bosun/ui/components/kanban-board.js</code>  +124 -18<br/>`+
        `<code>bosun/ui/styles/kanban.css</code>          +156 -3<br/>`+
        `<code>bosun/ui/demo.html</code>                 +312 -89<br/><br/>`+
        `3 files changed, 592 insertions(+), 110 deletions(-)`,

      git_log: () => `<strong>:file: Git Log</strong><br/><br/>`+
        `<code>a1b2c3d</code> feat(kanban): add repo badge and filter bar (PR #17)<br/>`+
        `<code>4e5f6a7</code> fix(ui): health card text contrast<br/>`+
        `<code>8b9c0d1</code> feat(site): landing page redesign<br/>`+
        `<code>e2f3a4b</code> fix(security): bulk remediation 287/300 alerts (PR #751)<br/>`+
        `<code>f5a6b7c</code> feat(oauth): GitHub App auth setup (PR #10)`,

      shell: () => `<strong>:monitor: Shell</strong> — <code>ls logs/</code><br/><br/>`+
        `<code>daemon.log  monitor.log  agent-42.log  agent-43.log  agent-44.log  telegram.log</code>`,

      history: () => `<strong>:cpu: Session History</strong><br/><br/>`+
        `├─ Session #1: Landing page redesign (bosun PR #17) — <em>in progress</em><br/>`+
        `├─ Session #2: Market order expiry (virtengine) — <em>in progress</em><br/>`+
        `├─ Session #6: Security bulk remediation (PR #751) — :check: done<br/>`+
        `├─ Session #7: Kanban filters + repo badge — <em>in progress</em><br/>`+
        `└─ Session #8: MiniApp redesign (PR #754) — :check: done<br/><br/>`+
        `Total: 8 sessions this week, 142 turns`,

      threads: () => `<strong>:link: Active Threads</strong><br/><br/>`+
        `├─ Thread #1: <code>docs/bosun-improvement-plan</code> :dot: (18 turns)<br/>`+
        `├─ Thread #2: <code>ve/760-market-order-expiry</code> :dot: (12 turns)<br/>`+
        `├─ Thread #3: <code>bs/12-error-correlation</code> :dot: (6 turns)<br/>`+
        `└─ Thread #4: <code>primary-agent</code> :dot: idle<br/><br/>`+
        `Total: 4 threads (3 active)`,
      threads_clear: () => `<strong>:link: Registry cleared.</strong> All idle threads removed.`,

      steer: () => `<strong>:compass: Steer Agent</strong><br/><br/>Use: <code>/steer &lt;directive&gt;</code><br/><br/>Example:<br/><code>/steer focus on adding tests first</code><br/><code>/steer skip the CLI and focus on keeper only</code>`,
      stop: () => `<strong>:close: Stop Agent</strong><br/><br/>No active agents running right now.`,

      kanban: () => `<strong>:chart: Kanban Board</strong><br/><br/>:edit: Draft: 2<br/>:clipboard: Todo: 3<br/>:dot: In Progress: 4<br/>:edit: In Review: 2<br/>:check: Done: 8<br/>:close: Error: 1<br/><br/>Total: 20 tasks across 2 repos`,

      pause: () => `<strong>:pause: Task processing paused.</strong><br/><br/>No new tasks will be dispatched. Active tasks continue.<br/>Use Resume to restart.`,
      resume: () => `<strong>:play: Task processing resumed.</strong><br/><br/>Fleet is picking up tasks from the backlog.`,
      restart: () => `<strong>:refresh: Restarting...</strong><br/><br/>No failed tasks to restart. All tasks healthy.`,
      cleanup: () => `<strong>:trash: Cleanup Results</strong><br/><br/>:check: 0 stale orchestrators removed<br/>:check: 0 stuck pushes cleared<br/>:check: 1 worktree pruned<br/>:check: 0 orphaned branches cleaned`,
      starttask: () => `<strong>:play: Starting task #46</strong>...<br/><br/>:clipboard: docs: update provider guide<br/>:bot: Assigned to: <code>codex-default</code><br/>:git: Branch: <code>ve/46-docs-provider-guide</code><br/><br/>:check: Task dispatched.`,

      plan3: () => `<strong>:grid: Planning 3 tasks...</strong><br/><br/>1. feat(hpc): GPU resource metering<br/>2. fix(provider): health check endpoint<br/>3. docs: update provider guide<br/><br/>:check: 3 tasks queued.`,
      plan5: () => `<strong>:grid: Planning 5 tasks...</strong><br/><br/>1. feat(hpc): GPU resource metering<br/>2. fix(provider): health check<br/>3. docs: update provider guide<br/>4. refactor(roles): simplify permissions<br/>5. test(escrow): settlement edge cases<br/><br/>:check: 5 tasks queued.`,
      plan10: () => `<strong>:grid: Planning 10 tasks...</strong><br/><br/>:check: 10 tasks seeded from backlog and queued.`,

      retry_manual: () => `<strong>:repeat: Manual Retry</strong><br/><br/>Retrying active task with clean context... :check: retry dispatched.`,
      retry_stuck: () => `<strong>:repeat: Stuck Retry</strong><br/><br/>Detecting stuck state... No stuck agents found.`,
      retry_ratelimit: () => `<strong>:repeat: Rate Limit Retry</strong><br/><br/>Waiting for rate limit cooldown... :check: Retrying in 30s.`,

      // Task list statuses
      tasks_backlog: () => tasksByStatus('Backlog', ['queued']),
      tasks_draft: () => '<strong>:edit: Draft Tasks</strong><br/><br/>No draft tasks.',
      tasks_todo: () => tasksByStatus('Todo', ['queued']),
      tasks_active: () => tasksByStatus('Active', ['running']),
      tasks_review: () => '<strong>:search: Review</strong><br/><br/>No tasks in review.',
      tasks_blocked: () => '<strong>:ban: Blocked</strong><br/><br/>No blocked tasks.',
      tasks_done: () => tasksByStatus('Done', ['done']),

      agentlogs_escrow: () => `<strong>:folder: Agent Logs — docs/bosun-improvement-plan</strong><br/><br/><pre>[09:12] Starting session for bosun PR #17\n[09:14] Reading site/indexv2.html\n[09:18] Refactoring demo tabs for mobile\n[09:24] Added helm SVG hero\n[09:30] CI queued on PR #17</pre>`,
      agentlogs_hpc: () => `<strong>:folder: Agent Logs — ve/760-market-order-expiry</strong><br/><br/><pre>[10:05] Starting session...\n[10:06] Reading x/market/keeper/order.go\n[10:10] Implementing auto-expiry TTL\n[10:15] Writing order_test.go...</pre>`,
      agentlogs_docs: () => `<strong>:folder: Agent Logs — bs/12-error-correlation</strong><br/><br/><pre>[Queued — not yet started]</pre>`,

      kill_thread_44: () => `<strong>:trash: Thread Invalidated</strong><br/><br/>Thread <code>ve/44-escrow-batch</code> has been invalidated. Session will restart on next dispatch.`,
      kill_thread_45: () => `<strong>:trash: Thread Invalidated</strong><br/><br/>Thread <code>ve/45-hpc-gpu</code> has been invalidated.`,

      background_active: () => `<strong>:server: Backgrounded</strong><br/><br/>Active agent moved to background mode. It will continue working silently.`,
      background_new: () => `<strong>:server: New Background Task</strong><br/><br/>Describe the task to run in background mode.`,

      mp_0: () => mpSet(0), mp_1: () => mpSet(1), mp_2: () => mpSet(2),
      mp_3: () => mpSet(3), mp_4: () => mpSet(4), mp_6: () => mpSet(6),
      mp_8: () => mpSet(8), mp_12: () => mpSet(12), mp_16: () => mpSet(16),

      model_opus: () => `<strong>:bot: Model set:</strong> <code>claude-opus-4-6</code><br/>Next tasks will use this model.`,
      model_o4: () => `<strong>:bot: Model set:</strong> <code>o4-mini</code>`,
      model_gpt5: () => `<strong>:bot: Model set:</strong> <code>gpt-5.2-codex</code>`,
      model_default: () => `<strong>:bot: Model reset to default</strong> routing policy.`,

      sdk_copilot: () => `<strong>:box: SDK:</strong> <code>COPILOT</code> selected.`,
      sdk_codex: () => `<strong>:box: SDK:</strong> <code>CODEX</code> selected.`,
      sdk_auto: () => `<strong>:box: SDK:</strong> <code>AUTO</code> — round-robin.`,
      sdk_status: () => `<strong>:settings: SDK Status</strong><br/><br/>:check: Copilot SDK: loaded<br/>:check: Codex SDK: loaded<br/>:check: GitHub CLI: authenticated<br/>:check: Telegram API: connected`,

      region_us: () => `<strong>:globe: Region:</strong> <code>US East</code> selected.`,
      region_eu: () => `<strong>:globe: Region:</strong> <code>EU North (Sweden)</code> selected.`,
      region_auto: () => `<strong>:globe: Region:</strong> <code>Auto</code> — lowest latency.`,

      autobacklog: () => `<strong>:repeat: Auto Backlog:</strong> Enabled<br/><br/>New GitHub issues matching label filters will be auto-added to the kanban backlog.`,
      requirements: () => `<strong>:ruler: Requirements:</strong><br/><br/>Task requirements are parsed from issue descriptions. Acceptance criteria extracted via LLM.`,
      route_task: () => `<strong>:target: Route Task</strong><br/><br/>Next queued task will be routed using weighted random policy across online executors.`,
      container: () => `<strong>:box: Container Status</strong><br/><br/>Container Mode: <code>disabled</code><br/>Available: Docker, Podman<br/><br/>Enable with <code>CONTAINER_MODE=docker</code>`,

      integration_github: () => `<strong>:git: GitHub</strong> — :check: Connected<br/><br/>Org: <code>virtengine</code><br/>Repos: <code>bosun</code>, <code>virtengine</code><br/>Kanban: bidirectional sync`,
      integration_telegram: () => `<strong>:phone: Telegram</strong> — :check: Bot active<br/><br/>Bot: <code>@bosun_bot</code><br/>MiniApp: enabled<br/>Sticky menu: active`,
      integration_vscode: () => `<strong>:monitor: VS Code</strong> — :check: Copilot extension linked<br/><br/>Agent: copilot-claude<br/>MCP servers: connected`,
      integration_whatsapp: () => `<strong>:phone: WhatsApp</strong> — Not configured<br/><br/>Run <code>bosun --whatsapp-auth</code> to set up.`,
    };

    function tasksByStatus(label, statuses) {
      const icons = { running: ':dot:', queued: ':clock:', done: ':check:', failed: ':close:', cancelled: ':dot:' };
      const filtered = TASKS.filter(t => statuses.includes(t.status));
      if (!filtered.length) return `<strong>${label}</strong><br/><br/>No tasks with this status.`;
      return `<strong>${label} Tasks</strong> (${filtered.length})<br/><br/>` +
        filtered.map(t => `${icons[t.status]||'·'} <strong>${t.title}</strong> — <code>${t.status}</code>`).join('<br/>');
    }

    function mpSet(n) {
      return `<strong>:zap: Max Parallel set to <code>${n}</code></strong><br/><br/>${n === 0 ? 'Task processing effectively paused.' : `Up to ${n} tasks will run concurrently.`}`;
    }

    // ══════════════════════════════════════════════════════════════════
    //  PANEL NAVIGATION ENGINE
    // ══════════════════════════════════════════════════════════════════

    function renderScreen(screenId) {
      const screen = SCREENS[screenId];
      if (!screen) return;

      currentScreen = screenId;
      setIconText(titleEl, screen.title);
      setIconText(bodyEl, screen.body);

      // Hide result when navigating
      resultEl.classList.remove('visible');
      resultEl.innerHTML = '';

      // Back / Home buttons
      if (screen.parent) {
        backBtn.classList.add('visible');
        homeBtn.classList.add('visible');
      } else {
        backBtn.classList.remove('visible');
        homeBtn.classList.remove('visible');
      }

      // Render keyboard
      kbEl.innerHTML = '';
      if (screen.keyboard) {
        screen.keyboard.forEach(row => {
          const rowEl = document.createElement('div');
          rowEl.className = 'bot-kb-row';
          row.forEach(btn => {
            const b = document.createElement('button');
            b.className = 'bot-kb-btn';
            setIconText(b, btn.text);

            if (btn.go) {
              // Navigate to sub-screen
              b.addEventListener('click', () => {
                navStack.push(currentScreen);
                renderScreen(btn.go);
              });
            } else if (btn.cmd) {
              // Execute command → show result
              b.addEventListener('click', () => {
                b.classList.add('cmd-flash');
                setTimeout(() => b.classList.remove('cmd-flash'), 200);
                const handler = CMDS[btn.cmd];
                if (handler) {
                  resultEl.innerHTML = iconizeHtml(handler());
                  resultEl.classList.add('visible');
                  // Also navigate to the tab if it maps
                  const tabMap = { status: 'dashboard', tasks: 'tasks', agents: 'agents', logs: 'logs', executor: 'control', health: 'dashboard' };
                  if (tabMap[btn.cmd] && window.__bosunSetTab) {
                    window.__bosunSetTab(tabMap[btn.cmd]);
                  }
                }
              });
            } else if (btn.action === 'close') {
              b.className = 'bot-kb-btn close-btn';
              b.addEventListener('click', closePanel);
            }

            rowEl.appendChild(b);
          });
          kbEl.appendChild(rowEl);
        });

        // Auto-add nav row for non-home screens
        if (screen.parent) {
          const navRow = document.createElement('div');
          navRow.className = 'bot-kb-row';

          const backB = document.createElement('button');
          backB.className = 'bot-kb-btn nav-btn';
          setIconText(backB, 'Back');
          backB.addEventListener('click', goBack);

          const homeB = document.createElement('button');
          homeB.className = 'bot-kb-btn nav-btn';
          setIconText(homeB, 'Home');
          homeB.addEventListener('click', goHome);

          const closeB = document.createElement('button');
          closeB.className = 'bot-kb-btn close-btn';
          setIconText(closeB, 'Close');
          closeB.addEventListener('click', closePanel);

          navRow.appendChild(backB);
          navRow.appendChild(homeB);
          navRow.appendChild(closeB);
          kbEl.appendChild(navRow);
        }
      }
    }

    function goBack() {
      const screen = SCREENS[currentScreen];
      if (navStack.length > 0) {
        renderScreen(navStack.pop());
      } else if (screen && screen.parent) {
        renderScreen(screen.parent);
      }
    }

    function goHome() {
      navStack.length = 0;
      renderScreen('home');
    }

    function openPanel() {
      panelOpen = true;
      panel.classList.add('open');
      renderScreen('home');
    }

    function closePanel() {
      panelOpen = false;
      panel.classList.remove('open');
      navStack.length = 0;
    }

    // ── Event listeners ──
    fab?.addEventListener('click', () => panelOpen ? closePanel() : openPanel());
    backBtn.addEventListener('click', goBack);
    homeBtn.addEventListener('click', goHome);
    closeBtn.addEventListener('click', closePanel);

    // Close panel on Escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && panelOpen) closePanel();
    });

    // Fallback: if ES modules fail to load within 12s, show an error
    setTimeout(function() {
      var el = document.getElementById('boot-loader');
      if (el) el.innerHTML = '<div style="text-align:center;padding:40px;font-family:Inter,sans-serif;color:#94a3b8"><div style="font-size:18px;margin-bottom:8px">:alert: Failed to load</div><div style="font-size:12px;color:#64748b">Try refreshing. If this persists, run npm install in the bosun directory.</div></div>';
    }, 12000);

  })();
  </script>
</body>
</html>
